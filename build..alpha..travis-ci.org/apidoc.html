<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/milewise/node-soap#readme"

    >soap (v0.19.0)</a>
</h1>
<h4>A minimal node SOAP client</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap">module soap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BasicAuthSecurity">
            function <span class="apidocSignatureSpan">soap.</span>BasicAuthSecurity
            <span class="apidocSignatureSpan">(username, password, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BearerSecurity">
            function <span class="apidocSignatureSpan">soap.</span>BearerSecurity
            <span class="apidocSignatureSpan">(token, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client">
            function <span class="apidocSignatureSpan">soap.</span>Client
            <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurity">
            function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurity
            <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurityPFX">
            function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurityPFX
            <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient">
            function <span class="apidocSignatureSpan">soap.</span>HttpClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server">
            function <span class="apidocSignatureSpan">soap.</span>Server
            <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL">
            function <span class="apidocSignatureSpan">soap.</span>WSDL
            <span class="apidocSignatureSpan">(definition, uri, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurity">
            function <span class="apidocSignatureSpan">soap.</span>WSSecurity
            <span class="apidocSignatureSpan">(username, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurityCert">
            function <span class="apidocSignatureSpan">soap.</span>WSSecurityCert
            <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.createClient">
            function <span class="apidocSignatureSpan">soap.</span>createClient
            <span class="apidocSignatureSpan">(url, options, callback, endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.listen">
            function <span class="apidocSignatureSpan">soap.</span>listen
            <span class="apidocSignatureSpan">(server, pathOrOptions, services, xml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext">
            function <span class="apidocSignatureSpan">soap.</span>nscontext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.passwordDigest">
            function <span class="apidocSignatureSpan">soap.</span>passwordDigest
            <span class="apidocSignatureSpan">(nonce, created, password)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>soap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>BasicAuthSecurity.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>BearerSecurity.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>Client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurity.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurityPFX.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>HttpClient.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>WSDL.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>WSSecurity.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>WSSecurityCert.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>nscontext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>security</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>soap_stub</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.</span>wsdl</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.BasicAuthSecurity">module soap.BasicAuthSecurity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BasicAuthSecurity.BasicAuthSecurity">
            function <span class="apidocSignatureSpan">soap.</span>BasicAuthSecurity
            <span class="apidocSignatureSpan">(username, password, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.BasicAuthSecurity.prototype">module soap.BasicAuthSecurity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BasicAuthSecurity.prototype.addHeaders">
            function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>addHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BasicAuthSecurity.prototype.addOptions">
            function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>addOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BasicAuthSecurity.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>toXML
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.BearerSecurity">module soap.BearerSecurity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BearerSecurity.BearerSecurity">
            function <span class="apidocSignatureSpan">soap.</span>BearerSecurity
            <span class="apidocSignatureSpan">(token, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.BearerSecurity.prototype">module soap.BearerSecurity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BearerSecurity.prototype.addHeaders">
            function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>addHeaders
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BearerSecurity.prototype.addOptions">
            function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>addOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.BearerSecurity.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>toXML
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.Client">module soap.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.Client">
            function <span class="apidocSignatureSpan">soap.</span>Client
            <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.super_">
            function <span class="apidocSignatureSpan">soap.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.Client.prototype">module soap.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._defineMethod">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_defineMethod
            <span class="apidocSignatureSpan">(method, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._definePort">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_definePort
            <span class="apidocSignatureSpan">(port, endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._defineService">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_defineService
            <span class="apidocSignatureSpan">(service, endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._getArgsScheme">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_getArgsScheme
            <span class="apidocSignatureSpan">(methodName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._initializeOptions">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_initializeOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._initializeServices">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_initializeServices
            <span class="apidocSignatureSpan">(endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._invoke">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_invoke
            <span class="apidocSignatureSpan">(method, args, location, callback, options, extraHeaders)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._isSequenceRequired">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_isSequenceRequired
            <span class="apidocSignatureSpan">(methodName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype._setSequenceArgs">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_setSequenceArgs
            <span class="apidocSignatureSpan">(argsScheme, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.addBodyAttribute">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addBodyAttribute
            <span class="apidocSignatureSpan">(bodyAttribute, name, namespace, xmlns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.addHttpHeader">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addHttpHeader
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.addSoapHeader">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addSoapHeader
            <span class="apidocSignatureSpan">(soapHeader, name, namespace, xmlns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.changeSoapHeader">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>changeSoapHeader
            <span class="apidocSignatureSpan">(index, soapHeader, name, namespace, xmlns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.clearBodyAttributes">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearBodyAttributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.clearHttpHeaders">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearHttpHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.clearSoapHeaders">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearSoapHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.describe">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>describe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.getBodyAttributes">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getBodyAttributes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.getHttpHeaders">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getHttpHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.getSoapHeaders">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getSoapHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.setEndpoint">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setEndpoint
            <span class="apidocSignatureSpan">(endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.setSOAPAction">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setSOAPAction
            <span class="apidocSignatureSpan">(SOAPAction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Client.prototype.setSecurity">
            function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setSecurity
            <span class="apidocSignatureSpan">(security)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.ClientSSLSecurity">module soap.ClientSSLSecurity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurity.ClientSSLSecurity">
            function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurity
            <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.ClientSSLSecurity.prototype">module soap.ClientSSLSecurity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurity.prototype.addOptions">
            function <span class="apidocSignatureSpan">soap.ClientSSLSecurity.prototype.</span>addOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurity.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.ClientSSLSecurity.prototype.</span>toXML
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.ClientSSLSecurityPFX">module soap.ClientSSLSecurityPFX</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurityPFX.ClientSSLSecurityPFX">
            function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurityPFX
            <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.ClientSSLSecurityPFX.prototype">module soap.ClientSSLSecurityPFX.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurityPFX.prototype.addOptions">
            function <span class="apidocSignatureSpan">soap.ClientSSLSecurityPFX.prototype.</span>addOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.ClientSSLSecurityPFX.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.ClientSSLSecurityPFX.prototype.</span>toXML
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.HttpClient">module soap.HttpClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient.HttpClient">
            function <span class="apidocSignatureSpan">soap.</span>HttpClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.HttpClient.prototype">module soap.HttpClient.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient.prototype.buildRequest">
            function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>buildRequest
            <span class="apidocSignatureSpan">(rurl, data, exheaders, exoptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient.prototype.handleResponse">
            function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>handleResponse
            <span class="apidocSignatureSpan">(req, res, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient.prototype.request">
            function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>request
            <span class="apidocSignatureSpan">(rurl, data, callback, exheaders, exoptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.HttpClient.prototype.requestStream">
            function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>requestStream
            <span class="apidocSignatureSpan">(rurl, data, exheaders, exoptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.Server">module soap.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.Server">
            function <span class="apidocSignatureSpan">soap.</span>Server
            <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.super_">
            function <span class="apidocSignatureSpan">soap.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.Server.prototype">module soap.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._envelope">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_envelope
            <span class="apidocSignatureSpan">(body, includeTimestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._executeMethod">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_executeMethod
            <span class="apidocSignatureSpan">(options, req, callback, includeTimestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._initializeOptions">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_initializeOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._process">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_process
            <span class="apidocSignatureSpan">(input, req, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._processRequestXml">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_processRequestXml
            <span class="apidocSignatureSpan">(req, res, xml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._requestListener">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_requestListener
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype._sendError">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_sendError
            <span class="apidocSignatureSpan">(soapFault, callback, includeTimestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype.addSoapHeader">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>addSoapHeader
            <span class="apidocSignatureSpan">(soapHeader, name, namespace, xmlns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype.changeSoapHeader">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>changeSoapHeader
            <span class="apidocSignatureSpan">(index, soapHeader, name, namespace, xmlns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype.clearSoapHeaders">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>clearSoapHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.Server.prototype.getSoapHeaders">
            function <span class="apidocSignatureSpan">soap.Server.prototype.</span>getSoapHeaders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSDL">module soap.WSDL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.WSDL">
            function <span class="apidocSignatureSpan">soap.</span>WSDL
            <span class="apidocSignatureSpan">(definition, uri, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSDL.prototype">module soap.WSDL.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>ignoreBaseNameSpaces</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._fromServices">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_fromServices
            <span class="apidocSignatureSpan">(services)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._fromXML">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_fromXML
            <span class="apidocSignatureSpan">(xml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._initializeOptions">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_initializeOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._parse">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_parse
            <span class="apidocSignatureSpan">(xml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._processNextInclude">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_processNextInclude
            <span class="apidocSignatureSpan">(includes, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._splitQName">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_splitQName
            <span class="apidocSignatureSpan">(nsName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype._xmlnsMap">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_xmlnsMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.describeServices">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>describeServices
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.filterOutIgnoredNameSpace">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>filterOutIgnoredNameSpace
            <span class="apidocSignatureSpan">(ns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.findChildSchemaObject">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findChildSchemaObject
            <span class="apidocSignatureSpan">(parameterTypeObj, childName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.findSchemaObject">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findSchemaObject
            <span class="apidocSignatureSpan">(nsURI, qname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.findSchemaType">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findSchemaType
            <span class="apidocSignatureSpan">(name, nsURI)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.isIgnoredNameSpace">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>isIgnoredNameSpace
            <span class="apidocSignatureSpan">(ns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.objectToDocumentXML">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToDocumentXML
            <span class="apidocSignatureSpan">(name, params, nsPrefix, nsURI, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.objectToRpcXML">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToRpcXML
            <span class="apidocSignatureSpan">(name, params, nsPrefix, nsURI, isParts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.objectToXML">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToXML
            <span class="apidocSignatureSpan">(obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.onReady">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>onReady
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.processAttributes">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>processAttributes
            <span class="apidocSignatureSpan">(child, nsContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.processIncludes">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>processIncludes
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>toXML
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSDL.prototype.xmlToObject">
            function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>xmlToObject
            <span class="apidocSignatureSpan">(xml, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>ignoredNamespaces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>valueKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>xmlKey</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSSecurity">module soap.WSSecurity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurity.WSSecurity">
            function <span class="apidocSignatureSpan">soap.</span>WSSecurity
            <span class="apidocSignatureSpan">(username, password, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSSecurity.prototype">module soap.WSSecurity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurity.prototype.toXML">
            function <span class="apidocSignatureSpan">soap.WSSecurity.prototype.</span>toXML
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSSecurityCert">module soap.WSSecurityCert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurityCert.WSSecurityCert">
            function <span class="apidocSignatureSpan">soap.</span>WSSecurityCert
            <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.WSSecurityCert.prototype">module soap.WSSecurityCert.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.WSSecurityCert.prototype.postProcess">
            function <span class="apidocSignatureSpan">soap.WSSecurityCert.prototype.</span>postProcess
            <span class="apidocSignatureSpan">(xml, envelopeKey)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.client">module soap.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.client.Client">
            function <span class="apidocSignatureSpan">soap.client.</span>Client
            <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.nscontext">module soap.nscontext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.nscontext">
            function <span class="apidocSignatureSpan">soap.</span>nscontext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.nscontext.prototype">module soap.nscontext.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.addNamespace">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>addNamespace
            <span class="apidocSignatureSpan">(prefix, nsUri, localOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.declareNamespace">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>declareNamespace
            <span class="apidocSignatureSpan">(prefix, nsUri)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.getNamespaceURI">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>getNamespaceURI
            <span class="apidocSignatureSpan">(prefix, localOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.getPrefix">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>getPrefix
            <span class="apidocSignatureSpan">(nsUri, localOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.popContext">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>popContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.pushContext">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>pushContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.nscontext.prototype.registerNamespace">
            function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>registerNamespace
            <span class="apidocSignatureSpan">(nsUri)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.security">module soap.security</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.BasicAuthSecurity">
            function <span class="apidocSignatureSpan">soap.security.</span>BasicAuthSecurity
            <span class="apidocSignatureSpan">(username, password, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.BearerSecurity">
            function <span class="apidocSignatureSpan">soap.security.</span>BearerSecurity
            <span class="apidocSignatureSpan">(token, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.ClientSSLSecurity">
            function <span class="apidocSignatureSpan">soap.security.</span>ClientSSLSecurity
            <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.ClientSSLSecurityPFX">
            function <span class="apidocSignatureSpan">soap.security.</span>ClientSSLSecurityPFX
            <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.WSSecurity">
            function <span class="apidocSignatureSpan">soap.security.</span>WSSecurity
            <span class="apidocSignatureSpan">(username, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.security.WSSecurityCert">
            function <span class="apidocSignatureSpan">soap.security.</span>WSSecurityCert
            <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.server">module soap.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.server.Server">
            function <span class="apidocSignatureSpan">soap.server.</span>Server
            <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.soap">module soap.soap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.BasicAuthSecurity">
            function <span class="apidocSignatureSpan">soap.soap.</span>BasicAuthSecurity
            <span class="apidocSignatureSpan">(username, password, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.BearerSecurity">
            function <span class="apidocSignatureSpan">soap.soap.</span>BearerSecurity
            <span class="apidocSignatureSpan">(token, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.Client">
            function <span class="apidocSignatureSpan">soap.soap.</span>Client
            <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.ClientSSLSecurity">
            function <span class="apidocSignatureSpan">soap.soap.</span>ClientSSLSecurity
            <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.ClientSSLSecurityPFX">
            function <span class="apidocSignatureSpan">soap.soap.</span>ClientSSLSecurityPFX
            <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.HttpClient">
            function <span class="apidocSignatureSpan">soap.soap.</span>HttpClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.Server">
            function <span class="apidocSignatureSpan">soap.soap.</span>Server
            <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.WSDL">
            function <span class="apidocSignatureSpan">soap.soap.</span>WSDL
            <span class="apidocSignatureSpan">(definition, uri, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.WSSecurity">
            function <span class="apidocSignatureSpan">soap.soap.</span>WSSecurity
            <span class="apidocSignatureSpan">(username, password, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.WSSecurityCert">
            function <span class="apidocSignatureSpan">soap.soap.</span>WSSecurityCert
            <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.createClient">
            function <span class="apidocSignatureSpan">soap.soap.</span>createClient
            <span class="apidocSignatureSpan">(url, options, callback, endpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.listen">
            function <span class="apidocSignatureSpan">soap.soap.</span>listen
            <span class="apidocSignatureSpan">(server, pathOrOptions, services, xml)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap.passwordDigest">
            function <span class="apidocSignatureSpan">soap.soap.</span>passwordDigest
            <span class="apidocSignatureSpan">(nonce, created, password)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.soap.</span>security</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.soap_stub">module soap.soap_stub</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">soap.soap_stub.</span>errOnCreateClient</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.createClient">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>createClient
            <span class="apidocSignatureSpan">(wsdlUrl, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.createErroringStub">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>createErroringStub
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.createRespondingStub">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>createRespondingStub
            <span class="apidocSignatureSpan">(object, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.getStub">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>getStub
            <span class="apidocSignatureSpan">(aliasOrWsdlUrl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.registerClient">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>registerClient
            <span class="apidocSignatureSpan">(alias, urlToWsdl, clientStub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.soap_stub.reset">
            function <span class="apidocSignatureSpan">soap.soap_stub.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">soap.soap_stub.</span>security</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.utils">module soap.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.utils.findPrefix">
            function <span class="apidocSignatureSpan">soap.utils.</span>findPrefix
            <span class="apidocSignatureSpan">(xmlnsMapping, nsURI)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.utils.passwordDigest">
            function <span class="apidocSignatureSpan">soap.utils.</span>passwordDigest
            <span class="apidocSignatureSpan">(nonce, created, password)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">soap.utils.</span>TNS_PREFIX</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.soap.wsdl">module soap.wsdl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.wsdl.WSDL">
            function <span class="apidocSignatureSpan">soap.wsdl.</span>WSDL
            <span class="apidocSignatureSpan">(definition, uri, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.soap.wsdl.open_wsdl">
            function <span class="apidocSignatureSpan">soap.wsdl.</span>open_wsdl
            <span class="apidocSignatureSpan">(uri, options, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap" id="apidoc.module.soap">module soap</a></h1>


    <h2>
        <a href="#apidoc.element.soap.BasicAuthSecurity" id="apidoc.element.soap.BasicAuthSecurity">
        function <span class="apidocSignatureSpan">soap.</span>BasicAuthSecurity
        <span class="apidocSignatureSpan">(username, password, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BasicAuthSecurity(username, password, defaults) {
  this._username = username;
  this._password = password;
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as well.  The interface is quite simple. Each protocol defines 2 methods:
* `addOptions` - a method that accepts an options arg that is eventually passed directly to `request`
* `toXML` - a method that returns a string of XML.

### BasicAuthSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BasicAuthSecurity</span>(&#x27;username&#x27;, &#x27;password&#
x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.BearerSecurity(&#x27;token&#x27;));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.BearerSecurity" id="apidoc.element.soap.BearerSecurity">
        function <span class="apidocSignatureSpan">soap.</span>BearerSecurity
        <span class="apidocSignatureSpan">(token, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BearerSecurity(token, defaults) {
	this._token = token;
	this.defaults = {};
	_.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` javascript
  client.setSecurity(new soap.BasicAuthSecurity(&#x27;username&#x27;, &#x27;password&#x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BearerSecurity</span>(&#x27;token&#x27;));
```

### ClientSSLSecurity

_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client" id="apidoc.element.soap.Client">
        function <span class="apidocSignatureSpan">soap.</span>Client
        <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (wsdl, endpoint, options) {
  events.EventEmitter.call(this);
  options = options || {};
  this.wsdl = wsdl;
  this._initializeOptions(options);
  this._initializeServices(endpoint);
  this.httpClient = options.httpClient || new HttpClient(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurity" id="apidoc.element.soap.ClientSSLSecurity">
        function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurity
        <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurity(key, cert, ca, defaults) {
  if (key) {
    if(Buffer.isBuffer(key)) {
      this.key = key;
    } else if (typeof key === &#x27;string&#x27;) {
      this.key = fs.readFileSync(key);
    } else {
      throw new Error(&#x27;key should be a buffer or a string!&#x27;);
    }
  }

  if (cert) {
    if(Buffer.isBuffer(cert)) {
      this.cert = cert;
    } else if (typeof cert === &#x27;string&#x27;) {
      this.cert = fs.readFileSync(cert);
    } else {
      throw new Error(&#x27;cert should be a buffer or a string!&#x27;);
    }
  }

  if (ca) {
    if(Buffer.isBuffer(ca) || Array.isArray(ca)) {
      this.ca = ca;
    } else if (typeof ca === &#x27;string&#x27;) {
      this.ca = fs.readFileSync(ca);
    } else {
      defaults = ca;
      this.ca = null;
    }
  }

  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
* `strictSSL: false`
* `secureOptions: constants.SSL_OP_NO_TLSv1_2` (this is likely needed for node &#x3e;= 10.0)

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">ClientSSLSecurity</span>(
    &#x27;/path/to/key&#x27;
    , &#x27;/path/to/cert&#x27;
    , {/*default request options*/}
  ));
```

### WSSecurity
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurityPFX" id="apidoc.element.soap.ClientSSLSecurityPFX">
        function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurityPFX
        <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurityPFX(pfx, passphrase, defaults) {
  if (typeof passphrase === &#x27;object&#x27;) {
    defaults = passphrase;
  }
  if (pfx) {
    if (Buffer.isBuffer(pfx)) {
      this.pfx = pfx;
    } else if (typeof pfx === &#x27;string&#x27;) {
      this.pfx = fs.readFileSync(pfx);
    } else {
      throw new Error(&#x27;supplied pfx file should be a buffer or a file location&#x27;);
    }
  }

  if (passphrase) {
    if (typeof passphrase === &#x27;string&#x27;) {
      this.passphrase = passphrase;
    }
  }
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.HttpClient" id="apidoc.element.soap.HttpClient">
        function <span class="apidocSignatureSpan">soap.</span>HttpClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(options) {
  options = options || {};
  this._request = options.request || req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server" id="apidoc.element.soap.Server">
        function <span class="apidocSignatureSpan">soap.</span>Server
        <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (server, path, services, wsdl, options) {
  var self = this;

  events.EventEmitter.call(this);

  options = options || {};
  this.path = path;
  this.services = services;
  this.wsdl = wsdl;
  this.suppressStack = options &#x26;&#x26; options.suppressStack;

  if (path[path.length - 1] !== &#x27;/&#x27;)
    path += &#x27;/&#x27;;
  wsdl.onReady(function (err) {
    if (typeof server.route === &#x27;function&#x27; &#x26;&#x26; typeof server.use === &#x27;function&#x27;) {
      //handle only the required URL path for express server
      server.route(path).all(function (req, res, next) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        self._requestListener(req, res);
      });
    } else {
      var listeners = server.listeners(&#x27;request&#x27;).slice();
      server.removeAllListeners(&#x27;request&#x27;);
      server.addListener(&#x27;request&#x27;, function (req, res) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        var reqPath = url.parse(req.url).pathname;
        if (reqPath[reqPath.length - 1] !== &#x27;/&#x27;) {
          reqPath += &#x27;/&#x27;;
        }
        if (path === reqPath) {
          self._requestListener(req, res);
        } else {
          for (var i = 0, len = listeners.length; i &#x3c; len; i++) {
            listeners[i].call(this, req, res);
          }
        }
      });
    }
  });

  this._initializeOptions(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL" id="apidoc.element.soap.WSDL">
        function <span class="apidocSignatureSpan">soap.</span>WSDL
        <span class="apidocSignatureSpan">(definition, uri, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WSDL = function (definition, uri, options) {
  var self = this,
      fromFunc;

  this.uri = uri;
  this.callback = function() {
  };
  this._includesWsdl = [];

  // initialize WSDL cache
  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};

  this._initializeOptions(options);

  if (typeof definition === &#x27;string&#x27;) {
    definition = stripBom(definition);
    fromFunc = this._fromXML;
  }
  else if (typeof definition === &#x27;object&#x27;) {
    fromFunc = this._fromServices;
  }
  else {
    throw new Error(&#x27;WSDL constructor takes either an XML string or service definition&#x27;);
  }

  process.nextTick(function() {
    try {
      fromFunc.call(self, definition);
    } catch (e) {
      return self.callback(e.message);
    }

    self.processIncludes(function(err) {
      var name;
      if (err) {
        return self.callback(err);
      }

      self.definitions.deleteFixedAttrs();
      var services = self.services = self.definitions.services;
      if (services) {
        for (name in services) {
          services[name].postProcess(self.definitions);
        }
      }
      var complexTypes = self.definitions.complexTypes;
      if (complexTypes) {
        for (name in complexTypes) {
          complexTypes[name].deleteFixedAttrs();
        }
      }

      // for document style, for every binding, prepare input message element name to (methodName, output message element name)
mapping
      var bindings = self.definitions.bindings;
      for (var bindingName in bindings) {
        var binding = bindings[bindingName];
        if (typeof binding.style === &#x27;undefined&#x27;) {
          binding.style = &#x27;document&#x27;;
        }
        if (binding.style !== &#x27;document&#x27;)
          continue;
        var methods = binding.methods;
        var topEls = binding.topElements = {};
        for (var methodName in methods) {
          if (methods[methodName].input) {
            var inputName = methods[methodName].input.$name;
            var outputName=&#x22;&#x22;;
            if(methods[methodName].output )
              outputName = methods[methodName].output.$name;
            topEls[inputName] = {&#x22;methodName&#x22;: methodName, &#x22;outputName&#x22;: outputName};
          }
        }
      }

      // prepare soap envelope xmlns definition string
      self.xmlnsInEnvelope = self._xmlnsMap();

      self.callback(err, self);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSSecurity" id="apidoc.element.soap.WSSecurity">
        function <span class="apidocSignatureSpan">soap.</span>WSSecurity
        <span class="apidocSignatureSpan">(username, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurity(username, password, options) {
  options = options || {};
  this._username = username;
  this._password = password;
  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = &#x27;PasswordText
&#x27;, hasTimeStamp = true
  if (typeof options === &#x27;string&#x27;) {
    this._passwordType = options ? options : &#x27;PasswordText&#x27;;
    options = {};
  } else {
    this._passwordType = options.passwordType ? options.passwordType : &#x27;PasswordText&#x27;;
  }

  if (validPasswordTypes.indexOf(this._passwordType) === -1) {
    this._passwordType = &#x27;PasswordText&#x27;;
  }

  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === &#x27;boolean&#x27; ? !!options.hasTimeStamp : true;
  /*jshint eqnull:true */
  if (options.hasNonce != null) {
    this._hasNonce = !!options.hasNonce;
  }
  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === &#x27;boolean&#x27; ? !!options.hasTokenCreated :
true;
  if (options.actor != null) {
    this._actor = options.actor;
  }
  if (options.mustUnderstand != null) {
    this._mustUnderstand = !!options.mustUnderstand;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSSecurityCert" id="apidoc.element.soap.WSSecurityCert">
        function <span class="apidocSignatureSpan">soap.</span>WSSecurityCert
        <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurityCert(privatePEM, publicP12PEM, password, encoding) {
  if (!ursa) {
    throw new Error(&#x27;Module ursa must be installed to use WSSecurityCert&#x27;);
  }
  this.privateKey = ursa.createPrivateKey(privatePEM, password, encoding);
  this.publicP12PEM = publicP12PEM.toString().replace(&#x27;-----BEGIN CERTIFICATE-----&#x27;, &#x27;&#x27;).replace(&#x27;-----END CERTIFICATE-----&#x27;, &#x27;&#x27;).
replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;);

  this.signer = new SignedXml();
  this.signer.signingKey = this.privateKey.toPrivatePem();
  this.x509Id = &#x22;x509-&#x22; + generateId();

  var _this = this;
  this.signer.keyInfoProvider = {};
  this.signer.keyInfoProvider.getKeyInfo = function (key) {
    return wsseSecurityTokenTemplate({ x509Id: _this.x509Id });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

WS-Security X509 Certificate support.

``` javascript
  var privateKey = fs.readFileSync(privateKeyPath);
  var publicKey = fs.readFileSync(publicKeyPath);
  var password = &#x27;&#x27;; // optional password
  var wsSecurity = new soap.<span class="apidocCodeKeywordSpan">WSSecurityCert</span>(privateKey, publicKey, password, &#x27;utf8
&#x27;);
  client.setSecurity(wsSecurity);
```

_Note_: Optional dependency &#x27;ursa&#x27; is required to be installed successfully when WSSecurityCert is used.

## Handling XML Attributes, Value and XML (wsdlOptions).
Sometimes it is necessary to override the default behaviour of `node-soap` in order to deal with the special requirements
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.createClient" id="apidoc.element.soap.createClient">
        function <span class="apidocSignatureSpan">soap.</span>createClient
        <span class="apidocSignatureSpan">(url, options, callback, endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClient(url, options, callback, endpoint) {
  if (typeof options === &#x27;function&#x27;) {
    endpoint = callback;
    callback = options;
    options = {};
  }
  endpoint = options.endpoint || endpoint;
  _requestWSDL(url, options, function(err, wsdl) {
    callback(err, wsdl &#x26;&#x26; new Client(wsdl, endpoint, options));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;!-- DON&#x27;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&#x3e;


- [Features:](#features)
- [Install](#install)
- [Where can I file an issue?](#where-can-i-file-an-issue)
- [Module](#module)
- [soap.<span class="apidocCodeKeywordSpan">createClient</span>(url[, options], callback) - create a new SOAP client from a WSDL
 url. Also supports a local filesystem path.](#soapcreateclienturl-options-callback---create-a-new-soap-client-from-a-wsdl-url-also
-supports-a-local-filesystem-path)
- [soap.listen(*server*, *path*, *services*, *wsdl*) - create a new SOAP server that listens on *path* and provides *services*.](#
soaplistenserver-path-services-wsdl---create-a-new-soap-server-that-listens-on-path-and-provides-services)
- [Options](#options)
- [Server Logging](#server-logging)
- [Server Events](#server-events)
- [SOAP Fault](#soap-fault)
- [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
- [Server connection authorization](#server-connection-authorization)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.listen" id="apidoc.element.soap.listen">
        function <span class="apidocSignatureSpan">soap.</span>listen
        <span class="apidocSignatureSpan">(server, pathOrOptions, services, xml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(server, pathOrOptions, services, xml) {
  var options = {},
    path = pathOrOptions,
    uri = null;

  if (typeof pathOrOptions === &#x27;object&#x27;) {
    options = pathOrOptions;
    path = options.path;
    services = options.services;
    xml = options.xml;
    uri = options.uri;
  }

  var wsdl = new WSDL(xml || services, uri, options);
  return new Server(server, path, services, wsdl, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


- [Features:](#features)
- [Install](#install)
- [Where can I file an issue?](#where-can-i-file-an-issue)
- [Module](#module)
  - [soap.createClient(url[, options], callback) - create a new SOAP client from a WSDL url. Also supports a local filesystem path
.](#soapcreateclienturl-options-callback---create-a-new-soap-client-from-a-wsdl-url-also-supports-a-local-filesystem-path)
  - [soap.<span class="apidocCodeKeywordSpan">listen</span>(*server*, *path*, *services*, *wsdl*) - create a new SOAP server that
 listens on *path* and provides *services*.](#soaplistenserver-path-services-wsdl---create-a-new-soap-server-that-listens-on-path
-and-provides-services)
  - [Options](#options)
  - [Server Logging](#server-logging)
  - [Server Events](#server-events)
  - [SOAP Fault](#soap-fault)
  - [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
  - [Server connection authorization](#server-connection-authorization)
- [SOAP Headers](#soap-headers)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext" id="apidoc.element.soap.nscontext">
        function <span class="apidocSignatureSpan">soap.</span>nscontext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NamespaceContext() {
  if (!(this instanceof NamespaceContext)) {
    return new NamespaceContext();
  }
  this.scopes = [];
  this.pushContext();
  this.prefixCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.passwordDigest" id="apidoc.element.soap.passwordDigest">
        function <span class="apidocSignatureSpan">soap.</span>passwordDigest
        <span class="apidocSignatureSpan">(nonce, created, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function passwordDigest(nonce, created, password) {
  // digest = base64 ( sha1 ( nonce + created + password ) )
  var pwHash = crypto.createHash(&#x27;sha1&#x27;);
  var rawNonce = new Buffer(nonce || &#x27;&#x27;, &#x27;base64&#x27;).toString(&#x27;binary&#x27;);
  pwHash.update(rawNonce + created + password);
  return pwHash.digest(&#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` javascript
  server = soap.listen(...)
  server.authenticate = function(security) {
    var created, nonce, password, user, token;
    token = security.UsernameToken, user = token.Username,
            password = token.Password, nonce = token.Nonce, created = token.Created;
    return user === &#x27;user&#x27; &#x26;&#x26; password === soap.<span class="apidocCodeKeywordSpan">passwordDigest</span>(nonce
, created, &#x27;password&#x27;);
  };
```

### Server connection authorization

The `server.authorizeConnection` method is called prior to the soap service method.
If the method is defined and returns `false` then the incoming connection is
...</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.BasicAuthSecurity" id="apidoc.module.soap.BasicAuthSecurity">module soap.BasicAuthSecurity</a></h1>


    <h2>
        <a href="#apidoc.element.soap.BasicAuthSecurity.BasicAuthSecurity" id="apidoc.element.soap.BasicAuthSecurity.BasicAuthSecurity">
        function <span class="apidocSignatureSpan">soap.</span>BasicAuthSecurity
        <span class="apidocSignatureSpan">(username, password, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BasicAuthSecurity(username, password, defaults) {
  this._username = username;
  this._password = password;
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as well.  The interface is quite simple. Each protocol defines 2 methods:
* `addOptions` - a method that accepts an options arg that is eventually passed directly to `request`
* `toXML` - a method that returns a string of XML.

### BasicAuthSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BasicAuthSecurity</span>(&#x27;username&#x27;, &#x27;password&#
x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.BearerSecurity(&#x27;token&#x27;));
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.BasicAuthSecurity.prototype" id="apidoc.module.soap.BasicAuthSecurity.prototype">module soap.BasicAuthSecurity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.BasicAuthSecurity.prototype.addHeaders" id="apidoc.element.soap.BasicAuthSecurity.prototype.addHeaders">
        function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>addHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHeaders = function (headers) {
  headers.Authorization = &#x27;Basic &#x27; + new Buffer((this._username + &#x27;:&#x27; + this._password) || &#x27;&#x27;).toString(&#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//Add extra headers
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.<span class="apidocCodeKeywordSpan">addHeaders</span>(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.addOptions(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.BasicAuthSecurity.prototype.addOptions" id="apidoc.element.soap.BasicAuthSecurity.prototype.addOptions">
        function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>addOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOptions = function (options) {
  _.merge(options, this.defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.addHeaders(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.<span class="apidocCodeKeywordSpan">addOptions</span>(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.BasicAuthSecurity.prototype.toXML" id="apidoc.element.soap.BasicAuthSecurity.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.BasicAuthSecurity.prototype.</span>toXML
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function () {
  return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.BearerSecurity" id="apidoc.module.soap.BearerSecurity">module soap.BearerSecurity</a></h1>


    <h2>
        <a href="#apidoc.element.soap.BearerSecurity.BearerSecurity" id="apidoc.element.soap.BearerSecurity.BearerSecurity">
        function <span class="apidocSignatureSpan">soap.</span>BearerSecurity
        <span class="apidocSignatureSpan">(token, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BearerSecurity(token, defaults) {
	this._token = token;
	this.defaults = {};
	_.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` javascript
  client.setSecurity(new soap.BasicAuthSecurity(&#x27;username&#x27;, &#x27;password&#x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BearerSecurity</span>(&#x27;token&#x27;));
```

### ClientSSLSecurity

_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.BearerSecurity.prototype" id="apidoc.module.soap.BearerSecurity.prototype">module soap.BearerSecurity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.BearerSecurity.prototype.addHeaders" id="apidoc.element.soap.BearerSecurity.prototype.addHeaders">
        function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>addHeaders
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHeaders = function (headers) {
	headers.Authorization = &#x22;Bearer &#x22; + this._token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//Add extra headers
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.<span class="apidocCodeKeywordSpan">addHeaders</span>(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.addOptions(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.BearerSecurity.prototype.addOptions" id="apidoc.element.soap.BearerSecurity.prototype.addOptions">
        function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>addOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOptions = function (options) {
  _.merge(options, this.defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.addHeaders(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.<span class="apidocCodeKeywordSpan">addOptions</span>(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.BearerSecurity.prototype.toXML" id="apidoc.element.soap.BearerSecurity.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.BearerSecurity.prototype.</span>toXML
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function () {
	return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.Client" id="apidoc.module.soap.Client">module soap.Client</a></h1>


    <h2>
        <a href="#apidoc.element.soap.Client.Client" id="apidoc.element.soap.Client.Client">
        function <span class="apidocSignatureSpan">soap.</span>Client
        <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (wsdl, endpoint, options) {
  events.EventEmitter.call(this);
  options = options || {};
  this.wsdl = wsdl;
  this._initializeOptions(options);
  this._initializeServices(endpoint);
  this.httpClient = options.httpClient || new HttpClient(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.super_" id="apidoc.element.soap.Client.super_">
        function <span class="apidocSignatureSpan">soap.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.Client.prototype" id="apidoc.module.soap.Client.prototype">module soap.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.Client.prototype._defineMethod" id="apidoc.element.soap.Client.prototype._defineMethod">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_defineMethod
        <span class="apidocSignatureSpan">(method, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineMethod = function (method, location) {
  var self = this;
  var temp;
  return function(args, callback, options, extraHeaders) {
    if (typeof args === &#x27;function&#x27;) {
      callback = args;
      args = {};
    } else if (typeof options === &#x27;function&#x27;) {
      temp = callback;
      callback = options;
      options = temp;
    } else if (typeof extraHeaders === &#x27;function&#x27;) {
      temp = callback;
      callback = extraHeaders;
      extraHeaders = options;
      options = temp;
    }
    self._invoke(method, args, location, function(error, result, raw, soapHeader) {
      callback(error, result, raw, soapHeader);
    }, options, extraHeaders);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Client.prototype._definePort = function(port, endpoint) {
var location = endpoint,
  binding = port.binding,
  methods = binding.methods,
  def = {};
for (var name in methods) {
  def[name] = this.<span class="apidocCodeKeywordSpan">_defineMethod</span>(methods[name], location);
  this[name] = def[name];
}
return def;
};

Client.prototype._defineMethod = function(method, location) {
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._definePort" id="apidoc.element.soap.Client.prototype._definePort">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_definePort
        <span class="apidocSignatureSpan">(port, endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_definePort = function (port, endpoint) {
  var location = endpoint,
    binding = port.binding,
    methods = binding.methods,
    def = {};
  for (var name in methods) {
    def[name] = this._defineMethod(methods[name], location);
    this[name] = def[name];
  }
  return def;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;
};

Client.prototype._defineService = function(service, endpoint) {
var ports = service.ports,
  def = {};
for (var name in ports) {
  def[name] = this.<span class="apidocCodeKeywordSpan">_definePort</span>(ports[name], endpoint ? endpoint : ports[name].location
);
}
return def;
};

Client.prototype._definePort = function(port, endpoint) {
var location = endpoint,
  binding = port.binding,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._defineService" id="apidoc.element.soap.Client.prototype._defineService">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_defineService
        <span class="apidocSignatureSpan">(service, endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_defineService = function (service, endpoint) {
  var ports = service.ports,
    def = {};
  for (var name in ports) {
    def[name] = this._definePort(ports[name], endpoint ? endpoint : ports[name].location);
  }
  return def;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.SOAPAction = SOAPAction;
};

Client.prototype._initializeServices = function(endpoint) {
var definitions = this.wsdl.definitions,
  services = definitions.services;
for (var name in services) {
  this[name] = this.<span class="apidocCodeKeywordSpan">_defineService</span>(services[name], endpoint);
}
};

Client.prototype._initializeOptions = function(options) {
this.streamAllowed = options.stream;
this.wsdl.options.attributesKey = options.attributesKey || &#x27;attributes&#x27;;
this.wsdl.options.envelopeKey = options.envelopeKey || &#x27;soap&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._getArgsScheme" id="apidoc.element.soap.Client.prototype._getArgsScheme">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_getArgsScheme
        <span class="apidocSignatureSpan">(methodName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getArgsScheme = function (methodName) {
  var methodRequestName = _.result(this.wsdl.definitions, &#x27;messages.&#x27;+methodName+&#x27;.$name&#x27;);
  var args = _.result(this.wsdl.definitions, &#x27;messages.&#x27; + methodRequestName + &#x27;.parts&#x27;);

  if(typeof args === &#x27;undefined&#x27; &#x26;&#x26; typeof _.pick(args, &#x27;params&#x27;) !== &#x27;undefined&#x27;) {
    return [];
  }
  if(Object.keys(args).length === 1) {
    return [];
  }

  return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  alias = findPrefix(defs.xmlns, ns),
  headers = {
    &#x22;Content-Type&#x22;: &#x22;text/xml; charset=utf-8&#x22;
  },
  xmlnsSoap = &#x22;xmlns:&#x22; + envelopeKey + &#x22;=\&#x22;http://schemas.xmlsoap.org/soap/envelope/\&#x22;&#x22;;

if(this._isSequenceRequired(name)) {
  var argsScheme = this.<span class="apidocCodeKeywordSpan">_getArgsScheme</span>(name);
  if(argsScheme) {
    args = this._setSequenceArgs(argsScheme, args);
  }
}

if (this.wsdl.options.forceSoap12Headers) {
  headers[&#x22;Content-Type&#x22;] = &#x22;application/soap+xml; charset=utf-8&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._initializeOptions" id="apidoc.element.soap.Client.prototype._initializeOptions">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_initializeOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initializeOptions = function (options) {
  this.streamAllowed = options.stream;
  this.wsdl.options.attributesKey = options.attributesKey || &#x27;attributes&#x27;;
  this.wsdl.options.envelopeKey = options.envelopeKey || &#x27;soap&#x27;;
  if(options.ignoredNamespaces !== undefined) {
    if(options.ignoredNamespaces.override !== undefined) {
      if(options.ignoredNamespaces.override === true) {
        if(options.ignoredNamespaces.namespaces !== undefined) {
          this.wsdl.options.ignoredNamespaces = options.ignoredNamespaces.namespaces;
        }
      }
    }
  }
  if(options.overrideRootElement !== undefined) {
    this.wsdl.options.overrideRootElement = options.overrideRootElement;
  }
  this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
concatStream = require(&#x27;concat-stream&#x27;),
uuid = require(&#x27;uuid&#x27;);

var Client = function(wsdl, endpoint, options) {
events.EventEmitter.call(this);
options = options || {};
this.wsdl = wsdl;
this.<span class="apidocCodeKeywordSpan">_initializeOptions</span>(options);
this._initializeServices(endpoint);
this.httpClient = options.httpClient || new HttpClient(options);
};
util.inherits(Client, events.EventEmitter);

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._initializeServices" id="apidoc.element.soap.Client.prototype._initializeServices">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_initializeServices
        <span class="apidocSignatureSpan">(endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initializeServices = function (endpoint) {
  var definitions = this.wsdl.definitions,
    services = definitions.services;
  for (var name in services) {
    this[name] = this._defineService(services[name], endpoint);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
uuid = require(&#x27;uuid&#x27;);

var Client = function(wsdl, endpoint, options) {
events.EventEmitter.call(this);
options = options || {};
this.wsdl = wsdl;
this._initializeOptions(options);
this.<span class="apidocCodeKeywordSpan">_initializeServices</span>(endpoint);
this.httpClient = options.httpClient || new HttpClient(options);
};
util.inherits(Client, events.EventEmitter);

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
  this.soapHeaders = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._invoke" id="apidoc.element.soap.Client.prototype._invoke">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_invoke
        <span class="apidocSignatureSpan">(method, args, location, callback, options, extraHeaders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_invoke = function (method, args, location, callback, options, extraHeaders) {
  var self = this,
    name = method.$name,
    input = method.input,
    output = method.output,
    style = method.style,
    defs = this.wsdl.definitions,
    envelopeKey = this.wsdl.options.envelopeKey,
    ns = defs.$targetNamespace,
    encoding = &#x27;&#x27;,
    message = &#x27;&#x27;,
    xml = null,
    req = null,
    soapAction,
    alias = findPrefix(defs.xmlns, ns),
    headers = {
      &#x22;Content-Type&#x22;: &#x22;text/xml; charset=utf-8&#x22;
    },
    xmlnsSoap = &#x22;xmlns:&#x22; + envelopeKey + &#x22;=\&#x22;http://schemas.xmlsoap.org/soap/envelope/\&#x22;&#x22;;

  if(this._isSequenceRequired(name)) {
    var argsScheme = this._getArgsScheme(name);
    if(argsScheme) {
      args = this._setSequenceArgs(argsScheme, args);
    }
  }

  if (this.wsdl.options.forceSoap12Headers) {
    headers[&#x22;Content-Type&#x22;] = &#x22;application/soap+xml; charset=utf-8&#x22;;
    xmlnsSoap = &#x22;xmlns:&#x22; + envelopeKey + &#x22;=\&#x22;http://www.w3.org/2003/05/soap-envelope\&#x22;&#x22;;
  }

  if (this.SOAPAction) {
    soapAction = this.SOAPAction;
  } else if (method.soapAction !== undefined &#x26;&#x26; method.soapAction !== null) {
    soapAction = method.soapAction;
  } else {
    soapAction = ((ns.lastIndexOf(&#x22;/&#x22;) !== ns.length - 1) ? ns + &#x22;/&#x22; : ns) + name;
  }

  if (!this.wsdl.options.forceSoap12Headers) {
    headers.SOAPAction = &#x27;&#x22;&#x27; + soapAction + &#x27;&#x22;&#x27;;
  }

  options = options || {};

  //Add extra headers
  for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
  for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

  // Allow the security object to add headers
  if (self.security &#x26;&#x26; self.security.addHeaders)
    self.security.addHeaders(headers);
  if (self.security &#x26;&#x26; self.security.addOptions)
    self.security.addOptions(options);

  if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
    assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
    message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
    (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/soap/encoding/&#x22; &#x27;);
  } else {
    assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
    // pass `input.$lookupType` if `input.$type` could not be found
    message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input
.$lookupType));
  }
  xml = &#x22;&#x3c;?xml version=\&#x22;1.0\&#x22; encoding=\&#x22;utf-8\&#x22;?&#x3e;&#x22; +
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Envelope &#x22; +
    xmlnsSoap + &#x22; &#x22; +
    &#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
    encoding +
    this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
    ((self.soapHeaders || self.security) ?
      (
        &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
        (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
        (self.security &#x26;&#x26; !self.security.postProcess ? self.security.toXML() : &#x22;&#x22;) +
        &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
      )
      :
        &#x27;&#x27;
      ) +
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
    (self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
    (self.security &#x26;&#x26; self.security.postProcess ? &#x27; Id=&#x22;_0&#x22;&#x27; : &#x27;&#x27;) +
    &#x22;&#x3e;&#x22; +
    message +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Body&#x3e;&#x22; +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Envelope&#x3e;&#x22;;

  if(self.security &#x26;&#x26; self.security.postProcess){
    xml = self.security.postProcess(xml, envelopeKey);
  }

  self.lastMessage = message;
  self.lastRequest = xml;
  self.lastEndpoint = location;

  var eid = options.exchangeId || uuid.v4();

  self.emit(&#x27;message&#x27;, message, eid);
  self.emit(&#x27;request&#x27;, xml, eid);

  var tryJSONparse = function(body) {
    try {
      return JSON.parse(body);
    }
    catch(err) {
      return undefined;
    }
  };

  if (this.streamAllowed &#x26;&#x26; typeof self.httpClient.requestStream === &#x27;function&#x27;) {
    callback = _.once(callback);
    var startTime = Date.now();
    req = self.httpClient.requestStream(locat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = temp;
  } else if (typeof extraHeaders === &#x27;function&#x27;) {
    temp = callback;
    callback = extraHeaders;
    extraHeaders = options;
    options = temp;
  }
  self.<span class="apidocCodeKeywordSpan">_invoke</span>(method, args, location, function(error, result, raw, soapHeader) {
    callback(error, result, raw, soapHeader);
  }, options, extraHeaders);
};
};

Client.prototype._isSequenceRequired = function(methodName) {
var tns = this.wsdl.definitions.$targetNamespace;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._isSequenceRequired" id="apidoc.element.soap.Client.prototype._isSequenceRequired">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_isSequenceRequired
        <span class="apidocSignatureSpan">(methodName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isSequenceRequired = function (methodName) {
  var tns = this.wsdl.definitions.$targetNamespace;
  var methodRequestName = _.result(this.wsdl.definitions, &#x27;messages.&#x27; + methodName + &#x27;.$name&#x27;);
  var args = _.result(this.wsdl.definitions, &#x27;messages.&#x27; + methodRequestName + &#x27;.parts&#x27;);

  if(typeof args === &#x27;undefined&#x27; &#x26;&#x26; typeof _.pick(args, &#x27;params&#x27;) !== &#x27;undefined&#x27;) {
    return false;
  }
  if(Object.keys(args).length === 1) {
    return false;
  }

  var complexTypeName = _.result(this.wsdl.definitions, &#x27;messages.&#x27; + methodRequestName + &#x27;.element.$name&#x27;);
  var modeOfComplexType = _.result(
    this.wsdl.definitions,
    &#x27;schemas[\&#x27;&#x27; + tns + &#x27;\&#x27;].elements.&#x27; + complexTypeName + &#x27;.children[0].children[0].name&#x27;);

  if(modeOfComplexType === &#x27;sequence&#x27;) {
    return true;
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  soapAction,
  alias = findPrefix(defs.xmlns, ns),
  headers = {
    &#x22;Content-Type&#x22;: &#x22;text/xml; charset=utf-8&#x22;
  },
  xmlnsSoap = &#x22;xmlns:&#x22; + envelopeKey + &#x22;=\&#x22;http://schemas.xmlsoap.org/soap/envelope/\&#x22;&#x22;;

if(this.<span class="apidocCodeKeywordSpan">_isSequenceRequired</span>(name)) {
  var argsScheme = this._getArgsScheme(name);
  if(argsScheme) {
    args = this._setSequenceArgs(argsScheme, args);
  }
}

if (this.wsdl.options.forceSoap12Headers) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype._setSequenceArgs" id="apidoc.element.soap.Client.prototype._setSequenceArgs">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>_setSequenceArgs
        <span class="apidocSignatureSpan">(argsScheme, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setSequenceArgs = function (argsScheme, args) {
  var result = {};
  if(typeof argsScheme !== &#x27;object&#x27;) {
    return args;
  }
  for (var partIndex in argsScheme) {
    if(typeof args[partIndex] === &#x27;undefined&#x27;) {
      continue;
    }
    if(typeof argsScheme[partIndex] !== &#x27;object&#x27;) {
      result[partIndex] = args[partIndex];
    } else {
      result[partIndex] = this._setSequenceArgs(argsScheme[partIndex], args[partIndex]);
    }
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var partIndex in argsScheme) {
  if(typeof args[partIndex] === &#x27;undefined&#x27;) {
    continue;
  }
  if(typeof argsScheme[partIndex] !== &#x27;object&#x27;) {
    result[partIndex] = args[partIndex];
  } else {
    result[partIndex] = this.<span class="apidocCodeKeywordSpan">_setSequenceArgs</span>(argsScheme[partIndex], args[partIndex]);
  }
}
return result;
};

Client.prototype._getArgsScheme = function(methodName) {
var methodRequestName = _.result(this.wsdl.definitions, &#x27;messages.&#x27;+methodName+&#x27;.$name&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.addBodyAttribute" id="apidoc.element.soap.Client.prototype.addBodyAttribute">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addBodyAttribute
        <span class="apidocSignatureSpan">(bodyAttribute, name, namespace, xmlns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBodyAttribute = function (bodyAttribute, name, namespace, xmlns) {
  if (!this.bodyAttributes) {
    this.bodyAttributes = [];
  }
  if (typeof bodyAttribute === &#x27;object&#x27;) {
    var composition = &#x27;&#x27;;
    Object.getOwnPropertyNames(bodyAttribute).forEach(function(prop, idx, array) {
      composition += &#x27; &#x27; + prop + &#x27;=&#x22;&#x27; + bodyAttribute[prop] + &#x27;&#x22;&#x27;;
    });
    bodyAttribute = composition;
  }
  if (bodyAttribute.substr(0, 1) !== &#x27; &#x27;) bodyAttribute = &#x27; &#x27; + bodyAttribute;
  this.bodyAttributes.push(bodyAttribute);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.addHttpHeader" id="apidoc.element.soap.Client.prototype.addHttpHeader">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addHttpHeader
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addHttpHeader = function (name, value) {
  if (!this.httpHeaders) {
    this.httpHeaders = {};
  }
  this.httpHeaders[name] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Extra Headers (optional)

Object properties define extra HTTP headers to be sent on the request.

- Add custom User-Agent:
```javascript
client.<span class="apidocCodeKeywordSpan">addHttpHeader</span>(&#x27;User-Agent&#x27;, `CustomUserAgent`);
```

#### Alternative method call using callback-last pattern

To align method call signature with node&#x27; standard callback-last patter and event allow promisification of method calls, the
 following method signatures are also supported:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.addSoapHeader" id="apidoc.element.soap.Client.prototype.addSoapHeader">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>addSoapHeader
        <span class="apidocSignatureSpan">(soapHeader, name, namespace, xmlns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addSoapHeader = function (soapHeader, name, namespace, xmlns) {
  if (!this.soapHeaders) {
    this.soapHeaders = [];
  }
  if (typeof soapHeader === &#x27;object&#x27;) {
    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
  }
  return this.soapHeaders.push(soapHeader) - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.changeSoapHeader" id="apidoc.element.soap.Client.prototype.changeSoapHeader">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>changeSoapHeader
        <span class="apidocSignatureSpan">(index, soapHeader, name, namespace, xmlns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeSoapHeader = function (index, soapHeader, name, namespace, xmlns) {
  if (!this.soapHeaders) {
    this.soapHeaders = [];
  }
  if (typeof soapHeader === &#x27;object&#x27;) {
    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
  }
  this.soapHeaders[index] = soapHeader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.clearBodyAttributes" id="apidoc.element.soap.Client.prototype.clearBodyAttributes">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearBodyAttributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearBodyAttributes = function () {
  this.bodyAttributes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.clearHttpHeaders" id="apidoc.element.soap.Client.prototype.clearHttpHeaders">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearHttpHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearHttpHeaders = function () {
  this.httpHeaders = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.clearSoapHeaders" id="apidoc.element.soap.Client.prototype.clearSoapHeaders">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>clearSoapHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearSoapHeaders = function () {
  this.soapHeaders = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.describe" id="apidoc.element.soap.Client.prototype.describe">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>describe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function () {
  var types = this.wsdl.definitions.types;
  return this.wsdl.describeServices();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  - [SOAP Fault](#soap-fault)
  - [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
  - [Server connection authorization](#server-connection-authorization)
- [SOAP Headers](#soap-headers)
  - [Received SOAP Headers](#received-soap-headers)
  - [Outgoing SOAP Headers](#outgoing-soap-headers)
- [Client](#client)
  - [Client.<span class="apidocCodeKeywordSpan">describe</span>() - description of services, ports and methods as a JavaScript object
](#clientdescribe---description-of-services-ports-and-methods-as-a-javascript-object)
  - [Client.setSecurity(security) - use the specified security protocol](#clientsetsecuritysecurity---use-the-specified-security
-protocol)
  - [Client.*method*(args, callback) - call *method* on the SOAP service.](#clientmethodargs-callback---call-method-on-the-soap-
service)
  - [Client.*service*.*port*.*method*(args, callback[, options[, extraHeaders]]) - call a *method* using a specific *service* and
 *port*](#clientserviceportmethodargs-callback-options-extraheaders---call-a-method-using-a-specific-service-and-port)
  - [Client.*lastRequest* - the property that contains last full soap request for client logging](#clientlastrequest---the-property
-that-contains-last-full-soap-request-for-client-logging)
  - [Client.setEndpoint(url) - overwrite the SOAP service endpoint address](#clientsetendpointurl---overwrite-the-soap-service-endpoint
-address)
  - [Client Events](#client-events)
- [Security](#security)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.getBodyAttributes" id="apidoc.element.soap.Client.prototype.getBodyAttributes">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getBodyAttributes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBodyAttributes = function () {
  return this.bodyAttributes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.getHttpHeaders" id="apidoc.element.soap.Client.prototype.getHttpHeaders">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getHttpHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHttpHeaders = function () {
  return this.httpHeaders;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.getSoapHeaders" id="apidoc.element.soap.Client.prototype.getSoapHeaders">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>getSoapHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSoapHeaders = function () {
  return this.soapHeaders;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.setEndpoint" id="apidoc.element.soap.Client.prototype.setEndpoint">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setEndpoint
        <span class="apidocSignatureSpan">(endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEndpoint = function (endpoint) {
  this.endpoint = endpoint;
  this._initializeServices(endpoint);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Outgoing SOAP Headers](#outgoing-soap-headers)
- [Client](#client)
- [Client.describe() - description of services, ports and methods as a JavaScript object](#clientdescribe---description-of-services
-ports-and-methods-as-a-javascript-object)
- [Client.setSecurity(security) - use the specified security protocol](#clientsetsecuritysecurity---use-the-specified-security-protocol
)
- [Client.*method*(args, callback) - call *method* on the SOAP service.](#clientmethodargs-callback---call-method-on-the-soap-service
)
- [Client.*service*.*port*.*method*(args, callback[, options[, extraHeaders]]) - call a *method* using a specific *service* and *
port*](#clientserviceportmethodargs-callback-options-extraheaders---call-a-method-using-a-specific-service-and-port)
- [Client.*lastRequest* - the property that contains last full soap request for client logging](#clientlastrequest---the-property
-that-contains-last-full-soap-request-for-client-logging)
- [Client.<span class="apidocCodeKeywordSpan">setEndpoint</span>(url) - overwrite the SOAP service endpoint address](#clientsetendpointurl
---overwrite-the-soap-service-endpoint-address)
- [Client Events](#client-events)
- [Security](#security)
- [BasicAuthSecurity](#basicauthsecurity)
- [BearerSecurity](#bearersecurity)
- [ClientSSLSecurity](#clientsslsecurity)
- [WSSecurity](#wssecurity)
- [WSSecurityCert](#wssecuritycert)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.setSOAPAction" id="apidoc.element.soap.Client.prototype.setSOAPAction">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setSOAPAction
        <span class="apidocSignatureSpan">(SOAPAction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSOAPAction = function (SOAPAction) {
  this.SOAPAction = SOAPAction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Client.prototype.setSecurity" id="apidoc.element.soap.Client.prototype.setSecurity">
        function <span class="apidocSignatureSpan">soap.Client.prototype.</span>setSecurity
        <span class="apidocSignatureSpan">(security)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSecurity = function (security) {
  this.security = security;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
- [Server connection authorization](#server-connection-authorization)
- [SOAP Headers](#soap-headers)
- [Received SOAP Headers](#received-soap-headers)
- [Outgoing SOAP Headers](#outgoing-soap-headers)
- [Client](#client)
- [Client.describe() - description of services, ports and methods as a JavaScript object](#clientdescribe---description-of-services
-ports-and-methods-as-a-javascript-object)
- [Client.<span class="apidocCodeKeywordSpan">setSecurity</span>(security) - use the specified security protocol](#clientsetsecuritysecurity
---use-the-specified-security-protocol)
- [Client.*method*(args, callback) - call *method* on the SOAP service.](#clientmethodargs-callback---call-method-on-the-soap-service
)
- [Client.*service*.*port*.*method*(args, callback[, options[, extraHeaders]]) - call a *method* using a specific *service* and *
port*](#clientserviceportmethodargs-callback-options-extraheaders---call-a-method-using-a-specific-service-and-port)
- [Client.*lastRequest* - the property that contains last full soap request for client logging](#clientlastrequest---the-property
-that-contains-last-full-soap-request-for-client-logging)
- [Client.setEndpoint(url) - overwrite the SOAP service endpoint address](#clientsetendpointurl---overwrite-the-soap-service-endpoint
-address)
- [Client Events](#client-events)
- [Security](#security)
- [BasicAuthSecurity](#basicauthsecurity)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.ClientSSLSecurity" id="apidoc.module.soap.ClientSSLSecurity">module soap.ClientSSLSecurity</a></h1>


    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurity.ClientSSLSecurity" id="apidoc.element.soap.ClientSSLSecurity.ClientSSLSecurity">
        function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurity
        <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurity(key, cert, ca, defaults) {
  if (key) {
    if(Buffer.isBuffer(key)) {
      this.key = key;
    } else if (typeof key === &#x27;string&#x27;) {
      this.key = fs.readFileSync(key);
    } else {
      throw new Error(&#x27;key should be a buffer or a string!&#x27;);
    }
  }

  if (cert) {
    if(Buffer.isBuffer(cert)) {
      this.cert = cert;
    } else if (typeof cert === &#x27;string&#x27;) {
      this.cert = fs.readFileSync(cert);
    } else {
      throw new Error(&#x27;cert should be a buffer or a string!&#x27;);
    }
  }

  if (ca) {
    if(Buffer.isBuffer(ca) || Array.isArray(ca)) {
      this.ca = ca;
    } else if (typeof ca === &#x27;string&#x27;) {
      this.ca = fs.readFileSync(ca);
    } else {
      defaults = ca;
      this.ca = null;
    }
  }

  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
* `strictSSL: false`
* `secureOptions: constants.SSL_OP_NO_TLSv1_2` (this is likely needed for node &#x3e;= 10.0)

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">ClientSSLSecurity</span>(
    &#x27;/path/to/key&#x27;
    , &#x27;/path/to/cert&#x27;
    , {/*default request options*/}
  ));
```

### WSSecurity
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.ClientSSLSecurity.prototype" id="apidoc.module.soap.ClientSSLSecurity.prototype">module soap.ClientSSLSecurity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurity.prototype.addOptions" id="apidoc.element.soap.ClientSSLSecurity.prototype.addOptions">
        function <span class="apidocSignatureSpan">soap.ClientSSLSecurity.prototype.</span>addOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOptions = function (options) {
  options.key = this.key;
  options.cert = this.cert;
  options.ca = this.ca;
  _.merge(options, this.defaults);
  options.agent = new https.Agent(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.addHeaders(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.<span class="apidocCodeKeywordSpan">addOptions</span>(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurity.prototype.toXML" id="apidoc.element.soap.ClientSSLSecurity.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.ClientSSLSecurity.prototype.</span>toXML
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function (headers) {
  return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.ClientSSLSecurityPFX" id="apidoc.module.soap.ClientSSLSecurityPFX">module soap.ClientSSLSecurityPFX</a></h1>


    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurityPFX.ClientSSLSecurityPFX" id="apidoc.element.soap.ClientSSLSecurityPFX.ClientSSLSecurityPFX">
        function <span class="apidocSignatureSpan">soap.</span>ClientSSLSecurityPFX
        <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurityPFX(pfx, passphrase, defaults) {
  if (typeof passphrase === &#x27;object&#x27;) {
    defaults = passphrase;
  }
  if (pfx) {
    if (Buffer.isBuffer(pfx)) {
      this.pfx = pfx;
    } else if (typeof pfx === &#x27;string&#x27;) {
      this.pfx = fs.readFileSync(pfx);
    } else {
      throw new Error(&#x27;supplied pfx file should be a buffer or a file location&#x27;);
    }
  }

  if (passphrase) {
    if (typeof passphrase === &#x27;string&#x27;) {
      this.passphrase = passphrase;
    }
  }
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.ClientSSLSecurityPFX.prototype" id="apidoc.module.soap.ClientSSLSecurityPFX.prototype">module soap.ClientSSLSecurityPFX.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurityPFX.prototype.addOptions" id="apidoc.element.soap.ClientSSLSecurityPFX.prototype.addOptions">
        function <span class="apidocSignatureSpan">soap.ClientSSLSecurityPFX.prototype.</span>addOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOptions = function (options) {
  options.pfx = this.pfx;
  if (this.passphrase) {
    options.passphrase = this.passphrase;
  }
  _.merge(options, this.defaults);
  options.agent = new https.Agent(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var header in this.httpHeaders ) { headers[header] = this.httpHeaders[header];  }
for (var attr in extraHeaders) { headers[attr] = extraHeaders[attr]; }

// Allow the security object to add headers
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.addHeaders(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.<span class="apidocCodeKeywordSpan">addOptions</span>(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.ClientSSLSecurityPFX.prototype.toXML" id="apidoc.element.soap.ClientSSLSecurityPFX.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.ClientSSLSecurityPFX.prototype.</span>toXML
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function (headers) {
  return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.HttpClient" id="apidoc.module.soap.HttpClient">module soap.HttpClient</a></h1>


    <h2>
        <a href="#apidoc.element.soap.HttpClient.HttpClient" id="apidoc.element.soap.HttpClient.HttpClient">
        function <span class="apidocSignatureSpan">soap.</span>HttpClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(options) {
  options = options || {};
  this._request = options.request || req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.HttpClient.prototype" id="apidoc.module.soap.HttpClient.prototype">module soap.HttpClient.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.HttpClient.prototype.buildRequest" id="apidoc.element.soap.HttpClient.prototype.buildRequest">
        function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>buildRequest
        <span class="apidocSignatureSpan">(rurl, data, exheaders, exoptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildRequest = function (rurl, data, exheaders, exoptions) {
  var curl = url.parse(rurl);
  var secure = curl.protocol === &#x27;https:&#x27;;
  var host = curl.hostname;
  var port = parseInt(curl.port, 10);
  var path = [curl.pathname || &#x27;/&#x27;, curl.search || &#x27;&#x27;, curl.hash || &#x27;&#x27;].join(&#x27;&#x27;);
  var method = data ? &#x27;POST&#x27; : &#x27;GET&#x27;;
  var headers = {
    &#x27;User-Agent&#x27;: &#x27;node-soap/&#x27; + VERSION,
    &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml,text/xml;q=0.9,*/*;q=0.8&#x27;,
    &#x27;Accept-Encoding&#x27;: &#x27;none&#x27;,
    &#x27;Accept-Charset&#x27;: &#x27;utf-8&#x27;,
    &#x27;Connection&#x27;: &#x27;close&#x27;,
    &#x27;Host&#x27;: host + (isNaN(port) ? &#x27;&#x27; : &#x27;:&#x27; + port)
  };
  var attr;
  var header;
  var mergeOptions = [&#x27;headers&#x27;];

  if (typeof data === &#x27;string&#x27;) {
    headers[&#x27;Content-Length&#x27;] = Buffer.byteLength(data, &#x27;utf8&#x27;);
    headers[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;
  }

  exheaders = exheaders || {};
  for (attr in exheaders) {
    headers[attr] = exheaders[attr];
  }

  var options = {
    uri: curl,
    method: method,
    headers: headers,
    followAllRedirects: true
  };


  options.body = data;


  exoptions = exoptions || {};
  for (attr in exoptions) {
    if (mergeOptions.indexOf(attr) !== -1) {
      for (header in exoptions[attr]) {
        options[attr][header] = exoptions[attr][header];
      }
    } else {
      options[attr] = exoptions[attr];
    }
  }
  debug(&#x27;Http request: %j&#x27;, options);
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.HttpClient.prototype.handleResponse" id="apidoc.element.soap.HttpClient.prototype.handleResponse">
        function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>handleResponse
        <span class="apidocSignatureSpan">(req, res, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleResponse = function (req, res, body) {
  debug(&#x27;Http response body: %j&#x27;, body);
  if (typeof body === &#x27;string&#x27;) {
    // Remove any extra characters that appear before or after the SOAP
    // envelope.
    var match =
      body.replace(/&#x3c;!--[\s\S]*?--&#x3e;/, &#x22;&#x22;).match(/(?:&#x3c;\?[^?]*\?&#x3e;[\s]*)?&#x3c;([^:]*):Envelope([\S\s]*)&#x3c;\/\1:Envelope&#x3e;/i);
    if (match) {
      body = match[0];
    }
  }
  return body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.HttpClient.prototype.request" id="apidoc.element.soap.HttpClient.prototype.request">
        function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>request
        <span class="apidocSignatureSpan">(rurl, data, callback, exheaders, exoptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (rurl, data, callback, exheaders, exoptions) {
  var self = this;
  var options = self.buildRequest(rurl, data, exheaders, exoptions);
  var headers = options.headers;
  var req = self._request(options, function(err, res, body) {
    if (err) {
      return callback(err);
    }
    body = self.handleResponse(req, res, body);
    callback(null, res, body);
  });

  return req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    return finish(obj, &#x27;&#x3c;stream&#x3e;&#x27;, response);
  });
});
return;
  }

  req = self.httpClient.<span class="apidocCodeKeywordSpan">request</span>(location, xml, function(err, response, body) {
self.lastResponse = body;
self.lastResponseHeaders = response &#x26;&#x26; response.headers;
self.lastElapsedTime = response &#x26;&#x26; response.elapsedTime;
self.emit(&#x27;response&#x27;, body, response, eid);

if (err) {
  callback(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.HttpClient.prototype.requestStream" id="apidoc.element.soap.HttpClient.prototype.requestStream">
        function <span class="apidocSignatureSpan">soap.HttpClient.prototype.</span>requestStream
        <span class="apidocSignatureSpan">(rurl, data, exheaders, exoptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requestStream = function (rurl, data, exheaders, exoptions) {
  var self = this;
  var options = self.buildRequest(rurl, data, exheaders, exoptions);
  return self._request(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return undefined;
  }
};

if (this.streamAllowed &#x26;&#x26; typeof self.httpClient.requestStream === &#x27;function&#x27;) {
  callback = _.once(callback);
  var startTime = Date.now();
  req = self.httpClient.<span class="apidocCodeKeywordSpan">requestStream</span>(location, xml, headers, options, self);
  self.lastRequestHeaders = req.headers;
  var onError = function onError(err) {
    self.lastResponse = null;
    self.lastResponseHeaders = null;
    self.lastElapsedTime = null;
    self.emit(&#x27;response&#x27;, null, null, eid);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.Server" id="apidoc.module.soap.Server">module soap.Server</a></h1>


    <h2>
        <a href="#apidoc.element.soap.Server.Server" id="apidoc.element.soap.Server.Server">
        function <span class="apidocSignatureSpan">soap.</span>Server
        <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (server, path, services, wsdl, options) {
  var self = this;

  events.EventEmitter.call(this);

  options = options || {};
  this.path = path;
  this.services = services;
  this.wsdl = wsdl;
  this.suppressStack = options &#x26;&#x26; options.suppressStack;

  if (path[path.length - 1] !== &#x27;/&#x27;)
    path += &#x27;/&#x27;;
  wsdl.onReady(function (err) {
    if (typeof server.route === &#x27;function&#x27; &#x26;&#x26; typeof server.use === &#x27;function&#x27;) {
      //handle only the required URL path for express server
      server.route(path).all(function (req, res, next) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        self._requestListener(req, res);
      });
    } else {
      var listeners = server.listeners(&#x27;request&#x27;).slice();
      server.removeAllListeners(&#x27;request&#x27;);
      server.addListener(&#x27;request&#x27;, function (req, res) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        var reqPath = url.parse(req.url).pathname;
        if (reqPath[reqPath.length - 1] !== &#x27;/&#x27;) {
          reqPath += &#x27;/&#x27;;
        }
        if (path === reqPath) {
          self._requestListener(req, res);
        } else {
          for (var i = 0, len = listeners.length; i &#x3c; len; i++) {
            listeners[i].call(this, req, res);
          }
        }
      });
    }
  });

  this._initializeOptions(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.super_" id="apidoc.element.soap.Server.super_">
        function <span class="apidocSignatureSpan">soap.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.Server.prototype" id="apidoc.module.soap.Server.prototype">module soap.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.Server.prototype._envelope" id="apidoc.element.soap.Server.prototype._envelope">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_envelope
        <span class="apidocSignatureSpan">(body, includeTimestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_envelope = function (body, includeTimestamp) {
  var defs = this.wsdl.definitions,
    ns = defs.$targetNamespace,
    encoding = &#x27;&#x27;,
    alias = findPrefix(defs.xmlns, ns);
  var xml = &#x22;&#x3c;?xml version=\&#x22;1.0\&#x22; encoding=\&#x22;utf-8\&#x22;?&#x3e;&#x22; +
    &#x22;&#x3c;soap:Envelope xmlns:soap=\&#x22;http://schemas.xmlsoap.org/soap/envelope/\&#x22; &#x22; +
    encoding +
    this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27;;
  var headers = &#x27;&#x27;;

  if (includeTimestamp) {
    var now = new Date();
    var created = getDateString(now);
    var expires = getDateString(new Date(now.getTime() + (1000 * 600)));

    headers += &#x22;&#x3c;o:Security soap:mustUnderstand=\&#x22;1\&#x22; &#x22; +
      &#x22;xmlns:o=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\&#x22; &#x22; +
      &#x22;xmlns:u=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\&#x22;&#x3e;&#x22; +
      &#x22;    &#x3c;u:Timestamp u:Id=\&#x22;_0\&#x22;&#x3e;&#x22; +
      &#x22;      &#x3c;u:Created&#x3e;&#x22; + created + &#x22;&#x3c;/u:Created&#x3e;&#x22; +
      &#x22;      &#x3c;u:Expires&#x3e;&#x22; + expires + &#x22;&#x3c;/u:Expires&#x3e;&#x22; +
      &#x22;    &#x3c;/u:Timestamp&#x3e;&#x22; +
      &#x22;  &#x3c;/o:Security&#x3e;\n&#x22;;
  }

  if (this.soapHeaders) {
    headers += this.soapHeaders.join(&#x22;\n&#x22;);
  }

  if (headers !== &#x27;&#x27;) {
    xml += &#x22;&#x3c;soap:Header&#x3e;&#x22; + headers + &#x22;&#x3c;/soap:Header&#x3e;&#x22;;
  }

  xml += &#x22;&#x3c;soap:Body&#x3e;&#x22; +
    body +
    &#x22;&#x3c;/soap:Body&#x3e;&#x22; +
    &#x22;&#x3c;/soap:Envelope&#x3e;&#x22;;
  return xml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  args = options.args,
  style = options.style,
  handled = false;

try {
  method = this.services[serviceName][portName][methodName];
} catch (error) {
  return callback(this.<span class="apidocCodeKeywordSpan">_envelope</span>(&#x27;&#x27;, includeTimestamp));
}

function handleResult(error, result) {
  if (handled)
    return;
  handled = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._executeMethod" id="apidoc.element.soap.Server.prototype._executeMethod">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_executeMethod
        <span class="apidocSignatureSpan">(options, req, callback, includeTimestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_executeMethod = function (options, req, callback, includeTimestamp) {
  options = options || {};
  var self = this,
    method, body,
    serviceName = options.serviceName,
    portName = options.portName,
    methodName = options.methodName,
    outputName = options.outputName,
    args = options.args,
    style = options.style,
    handled = false;

  try {
    method = this.services[serviceName][portName][methodName];
  } catch (error) {
    return callback(this._envelope(&#x27;&#x27;, includeTimestamp));
  }

  function handleResult(error, result) {
    if (handled)
      return;
    handled = true;

    if (error &#x26;&#x26; error.Fault !== undefined) {
      return self._sendError(error.Fault, callback, includeTimestamp);
    }
    else if (result === undefined) {
      // Backward compatibility to support one argument callback style
      result = error;
    }

    if (style === &#x27;rpc&#x27;) {
      body = self.wsdl.objectToRpcXML(outputName, result, &#x27;&#x27;, self.wsdl.definitions.$targetNamespace);
    } else {
      var element = self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output;
      body = self.wsdl.objectToDocumentXML(outputName, result, element.targetNSAlias, element.targetNamespace);
    }
    callback(self._envelope(body, includeTimestamp));
  }

  if (!self.wsdl.definitions.services[serviceName].ports[portName].binding.methods[methodName].output) {
    // no output defined = one-way operation so return empty response
    handled = true;
    callback(&#x27;&#x27;);
  }

  var result = method(args, handleResult, options.headers, req);
  if (typeof result !== &#x27;undefined&#x27;) {
    handleResult(result);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (binding.style === &#x27;rpc&#x27;) {
methodName = Object.keys(body)[0];

self.emit(&#x27;request&#x27;, obj, methodName);
if (headers)
  self.emit(&#x27;headers&#x27;, headers, methodName);

self.<span class="apidocCodeKeywordSpan">_executeMethod</span>({
  serviceName: serviceName,
  portName: portName,
  methodName: methodName,
  outputName: methodName + &#x27;Response&#x27;,
  args: body[methodName],
  headers: headers,
  style: &#x27;rpc&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._initializeOptions" id="apidoc.element.soap.Server.prototype._initializeOptions">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_initializeOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initializeOptions = function (options) {
  this.wsdl.options.attributesKey = options.attributesKey || &#x27;attributes&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
concatStream = require(&#x27;concat-stream&#x27;),
uuid = require(&#x27;uuid&#x27;);

var Client = function(wsdl, endpoint, options) {
events.EventEmitter.call(this);
options = options || {};
this.wsdl = wsdl;
this.<span class="apidocCodeKeywordSpan">_initializeOptions</span>(options);
this._initializeServices(endpoint);
this.httpClient = options.httpClient || new HttpClient(options);
};
util.inherits(Client, events.EventEmitter);

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._process" id="apidoc.element.soap.Server.prototype._process">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_process
        <span class="apidocSignatureSpan">(input, req, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_process = function (input, req, callback) {
  var self = this,
    pathname = url.parse(req.url).pathname.replace(/\/$/, &#x27;&#x27;),
    obj = this.wsdl.xmlToObject(input),
    body = obj.Body,
    headers = obj.Header,
    bindings = this.wsdl.definitions.bindings, binding,
    method, methodName,
    serviceName, portName,
    includeTimestamp = obj.Header &#x26;&#x26; obj.Header.Security &#x26;&#x26; obj.Header.Security.Timestamp;

  if (typeof self.authenticate === &#x27;function&#x27;) {
    if (!obj.Header || !obj.Header.Security) {
      throw new Error(&#x27;No security header&#x27;);
    }
    if (!self.authenticate(obj.Header.Security)) {
      throw new Error(&#x27;Invalid username or password&#x27;);
    }
  }

  if (typeof self.log === &#x27;function&#x27;) {
    self.log(&#x22;info&#x22;, &#x22;Attempting to bind to &#x22; + pathname);
  }

  //Avoid Cannot convert undefined or null to object due to Object.keys(body)
  //and throw more meaningful error
  if (!body) {
    throw new Error(&#x27;Failed to parse the SOAP Message body&#x27;);
  }

  // use port.location and current url to find the right binding
  binding = (function (self) {
    var services = self.wsdl.definitions.services;
    var firstPort;
    var name;
    for (name in services) {
      serviceName = name;
      var service = services[serviceName];
      var ports = service.ports;
      for (name in ports) {
        portName = name;
        var port = ports[portName];
        var portPathname = url.parse(port.location).pathname.replace(/\/$/, &#x27;&#x27;);

        if (typeof self.log === &#x27;function&#x27;) {
          self.log(&#x22;info&#x22;, &#x22;Trying &#x22; + portName + &#x22; from path &#x22; + portPathname);
        }

        if (portPathname === pathname)
          return port.binding;

        // The port path is almost always wrong for generated WSDLs
        if (!firstPort) {
          firstPort = port;
        }
      }
    }
    return !firstPort ? void 0 : firstPort.binding;
  })(this);

  if (!binding) {
    throw new Error(&#x27;Failed to bind to WSDL&#x27;);
  }

  try {
    if (binding.style === &#x27;rpc&#x27;) {
      methodName = Object.keys(body)[0];

      self.emit(&#x27;request&#x27;, obj, methodName);
      if (headers)
        self.emit(&#x27;headers&#x27;, headers, methodName);

      self._executeMethod({
        serviceName: serviceName,
        portName: portName,
        methodName: methodName,
        outputName: methodName + &#x27;Response&#x27;,
        args: body[methodName],
        headers: headers,
        style: &#x27;rpc&#x27;
      }, req, callback);
    } else {
      var messageElemName = (Object.keys(body)[0] === &#x27;attributes&#x27; ? Object.keys(body)[1] : Object.keys(body)[0]);
      var pair = binding.topElements[messageElemName];

      self.emit(&#x27;request&#x27;, obj, pair.methodName);
      if (headers)
        self.emit(&#x27;headers&#x27;, headers, pair.methodName);

      self._executeMethod({
        serviceName: serviceName,
        portName: portName,
        methodName: pair.methodName,
        outputName: pair.outputName,
        args: body[messageElemName],
        headers: headers,
        style: &#x27;document&#x27;
      }, req, callback, includeTimestamp);
    }
  }
  catch (error) {
    if (error.Fault !== undefined) {
      return self._sendError(error.Fault, callback, includeTimestamp);
    }

    throw error;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;
var result;
var error;
try {
  if (typeof self.log === &#x27;function&#x27;) {
    self.log(&#x22;received&#x22;, xml);
  }
  self.<span class="apidocCodeKeywordSpan">_process</span>(xml, req, function (result, statusCode) {
    if (statusCode) {
      res.statusCode = statusCode;
    }
    res.write(result);
    res.end();
    if (typeof self.log === &#x27;function&#x27;) {
      self.log(&#x22;replied&#x22;, result);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._processRequestXml" id="apidoc.element.soap.Server.prototype._processRequestXml">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_processRequestXml
        <span class="apidocSignatureSpan">(req, res, xml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processRequestXml = function (req, res, xml) {
  var self = this;
  var result;
  var error;
  try {
    if (typeof self.log === &#x27;function&#x27;) {
      self.log(&#x22;received&#x22;, xml);
    }
    self._process(xml, req, function (result, statusCode) {
      if (statusCode) {
        res.statusCode = statusCode;
      }
      res.write(result);
      res.end();
      if (typeof self.log === &#x27;function&#x27;) {
        self.log(&#x22;replied&#x22;, result);
      }
    });
  } catch (err) {
    if (err.Fault !== undefined) {
      return self._sendError(err.Fault, function (result, statusCode) {
        res.statusCode = statusCode || 500;
        res.write(result);
        res.end();
        if (typeof self.log === &#x27;function&#x27;) {
          self.log(&#x22;error&#x22;, err);
        }
      }, new Date().toISOString());
    } else {
      error = err.stack ? (self.suppressStack === true ? err.message : err.stack) : err;
      res.statusCode = 500;
      res.write(error);
      res.end();
      if (typeof self.log === &#x27;function&#x27;) {
        self.log(&#x22;error&#x22;, error);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  res.setHeader(&#x27;Content-Type&#x27;, &#x22;application/xml&#x22;);
}

//request body is already provided by an express middleware
//in this case unzipping should also be done by the express middleware itself
if (req.body) {
  return self.<span class="apidocCodeKeywordSpan">_processRequestXml</span>(req, res, req.body.toString());
}

var chunks = [], gunzip;
if (compress &#x26;&#x26; req.headers[&#x22;content-encoding&#x22;] === &#x22;gzip&#x22;) {
  gunzip = new compress.Gunzip();
  gunzip.init();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._requestListener" id="apidoc.element.soap.Server.prototype._requestListener">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_requestListener
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_requestListener = function (req, res) {
  var self = this;
  var reqParse = url.parse(req.url);
  var reqPath = reqParse.pathname;
  var reqQuery = reqParse.search;

  if (typeof self.log === &#x27;function&#x27;) {
    self.log(&#x22;info&#x22;, &#x22;Handling &#x22; + req.method + &#x22; on &#x22; + req.url);
  }

  if (req.method === &#x27;GET&#x27;) {
    if (reqQuery &#x26;&#x26; reqQuery.toLowerCase() === &#x27;?wsdl&#x27;) {
      if (typeof self.log === &#x27;function&#x27;) {
        self.log(&#x22;info&#x22;, &#x22;Wants the WSDL&#x22;);
      }
      res.setHeader(&#x22;Content-Type&#x22;, &#x22;application/xml&#x22;);
      res.write(self.wsdl.toXML());
    }
    res.end();
  } else if (req.method === &#x27;POST&#x27;) {
    if (typeof req.headers[&#x27;content-type&#x27;] !== &#x22;undefined&#x22;) {
      res.setHeader(&#x27;Content-Type&#x27;, req.headers[&#x27;content-type&#x27;]);
    } else {
      res.setHeader(&#x27;Content-Type&#x27;, &#x22;application/xml&#x22;);
    }

    //request body is already provided by an express middleware
    //in this case unzipping should also be done by the express middleware itself
    if (req.body) {
      return self._processRequestXml(req, res, req.body.toString());
    }

    var chunks = [], gunzip;
    if (compress &#x26;&#x26; req.headers[&#x22;content-encoding&#x22;] === &#x22;gzip&#x22;) {
      gunzip = new compress.Gunzip();
      gunzip.init();
    }
    req.on(&#x27;data&#x27;, function (chunk) {
      if (gunzip)
        chunk = gunzip.inflate(chunk, &#x22;binary&#x22;);
      chunks.push(chunk);
    });
    req.on(&#x27;end&#x27;, function () {
      var xml = chunks.join(&#x27;&#x27;);
      var result;
      var error;
      if (gunzip) {
        gunzip.end();
        gunzip = null;
      }
      self._processRequestXml(req, res, xml);
    });
  }
  else {
    res.end();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  server.route(path).all(function (req, res, next) {
    if (typeof self.authorizeConnection === &#x27;function&#x27;) {
      if (!self.authorizeConnection(req)) {
        res.end();
        return;
      }
    }
    self.<span class="apidocCodeKeywordSpan">_requestListener</span>(req, res);
  });
} else {
  var listeners = server.listeners(&#x27;request&#x27;).slice();
  server.removeAllListeners(&#x27;request&#x27;);
  server.addListener(&#x27;request&#x27;, function (req, res) {
    if (typeof self.authorizeConnection === &#x27;function&#x27;) {
      if (!self.authorizeConnection(req)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype._sendError" id="apidoc.element.soap.Server.prototype._sendError">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>_sendError
        <span class="apidocSignatureSpan">(soapFault, callback, includeTimestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendError = function (soapFault, callback, includeTimestamp) {
  var self = this,
    fault;

  var statusCode;
  if (soapFault.statusCode) {
    statusCode = soapFault.statusCode;
    soapFault.statusCode = undefined;
  }

  if (soapFault.faultcode) {
    // Soap 1.1 error style
    // Root element will be prependend with the soap NS
    // It must match the NS defined in the Envelope (set by the _envelope method)
    fault = self.wsdl.objectToDocumentXML(&#x22;soap:Fault&#x22;, soapFault, undefined);
  }
  else {
    // Soap 1.2 error style.
    // 3rd param is the NS prepended to all elements
    // It must match the NS defined in the Envelope (set by the _envelope method)
    fault = self.wsdl.objectToDocumentXML(&#x22;Fault&#x22;, soapFault, &#x22;soap&#x22;);
  }

  return callback(self._envelope(fault, includeTimestamp), statusCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res.end();
    if (typeof self.log === &#x27;function&#x27;) {
      self.log(&#x22;replied&#x22;, result);
    }
  });
} catch (err) {
  if (err.Fault !== undefined) {
    return self.<span class="apidocCodeKeywordSpan">_sendError</span>(err.Fault, function (result, statusCode) {
      res.statusCode = statusCode || 500;
      res.write(result);
      res.end();
      if (typeof self.log === &#x27;function&#x27;) {
        self.log(&#x22;error&#x22;, err);
      }
    }, new Date().toISOString());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype.addSoapHeader" id="apidoc.element.soap.Server.prototype.addSoapHeader">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>addSoapHeader
        <span class="apidocSignatureSpan">(soapHeader, name, namespace, xmlns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addSoapHeader = function (soapHeader, name, namespace, xmlns) {
  if (!this.soapHeaders) {
    this.soapHeaders = [];
  }
  if (typeof soapHeader === &#x27;object&#x27;) {
    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
  }
  return this.soapHeaders.push(soapHeader) - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype.changeSoapHeader" id="apidoc.element.soap.Server.prototype.changeSoapHeader">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>changeSoapHeader
        <span class="apidocSignatureSpan">(index, soapHeader, name, namespace, xmlns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeSoapHeader = function (index, soapHeader, name, namespace, xmlns) {
  if (!this.soapHeaders) {
    this.soapHeaders = [];
  }
  if (typeof soapHeader === &#x27;object&#x27;) {
    soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
  }
  this.soapHeaders[index] = soapHeader;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype.clearSoapHeaders" id="apidoc.element.soap.Server.prototype.clearSoapHeaders">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>clearSoapHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearSoapHeaders = function () {
  this.soapHeaders = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.Server.prototype.getSoapHeaders" id="apidoc.element.soap.Server.prototype.getSoapHeaders">
        function <span class="apidocSignatureSpan">soap.Server.prototype.</span>getSoapHeaders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSoapHeaders = function () {
  return this.soapHeaders;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSDL" id="apidoc.module.soap.WSDL">module soap.WSDL</a></h1>


    <h2>
        <a href="#apidoc.element.soap.WSDL.WSDL" id="apidoc.element.soap.WSDL.WSDL">
        function <span class="apidocSignatureSpan">soap.</span>WSDL
        <span class="apidocSignatureSpan">(definition, uri, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WSDL = function (definition, uri, options) {
  var self = this,
      fromFunc;

  this.uri = uri;
  this.callback = function() {
  };
  this._includesWsdl = [];

  // initialize WSDL cache
  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};

  this._initializeOptions(options);

  if (typeof definition === &#x27;string&#x27;) {
    definition = stripBom(definition);
    fromFunc = this._fromXML;
  }
  else if (typeof definition === &#x27;object&#x27;) {
    fromFunc = this._fromServices;
  }
  else {
    throw new Error(&#x27;WSDL constructor takes either an XML string or service definition&#x27;);
  }

  process.nextTick(function() {
    try {
      fromFunc.call(self, definition);
    } catch (e) {
      return self.callback(e.message);
    }

    self.processIncludes(function(err) {
      var name;
      if (err) {
        return self.callback(err);
      }

      self.definitions.deleteFixedAttrs();
      var services = self.services = self.definitions.services;
      if (services) {
        for (name in services) {
          services[name].postProcess(self.definitions);
        }
      }
      var complexTypes = self.definitions.complexTypes;
      if (complexTypes) {
        for (name in complexTypes) {
          complexTypes[name].deleteFixedAttrs();
        }
      }

      // for document style, for every binding, prepare input message element name to (methodName, output message element name)
mapping
      var bindings = self.definitions.bindings;
      for (var bindingName in bindings) {
        var binding = bindings[bindingName];
        if (typeof binding.style === &#x27;undefined&#x27;) {
          binding.style = &#x27;document&#x27;;
        }
        if (binding.style !== &#x27;document&#x27;)
          continue;
        var methods = binding.methods;
        var topEls = binding.topElements = {};
        for (var methodName in methods) {
          if (methods[methodName].input) {
            var inputName = methods[methodName].input.$name;
            var outputName=&#x22;&#x22;;
            if(methods[methodName].output )
              outputName = methods[methodName].output.$name;
            topEls[inputName] = {&#x22;methodName&#x22;: methodName, &#x22;outputName&#x22;: outputName};
          }
        }
      }

      // prepare soap envelope xmlns definition string
      self.xmlnsInEnvelope = self._xmlnsMap();

      self.callback(err, self);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSDL.prototype" id="apidoc.module.soap.WSDL.prototype">module soap.WSDL.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._fromServices" id="apidoc.element.soap.WSDL.prototype._fromServices">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_fromServices
        <span class="apidocSignatureSpan">(services)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fromServices = function (services) {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._fromXML" id="apidoc.element.soap.WSDL.prototype._fromXML">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_fromXML
        <span class="apidocSignatureSpan">(xml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fromXML = function (xml) {
  this.definitions = this._parse(xml);
  this.definitions.descriptions = {
    types:{}
  };
  this.xml = xml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._initializeOptions" id="apidoc.element.soap.WSDL.prototype._initializeOptions">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_initializeOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initializeOptions = function (options) {
  this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;
  this.options = {};

  var ignoredNamespaces = options ? options.ignoredNamespaces : null;

  if (ignoredNamespaces &#x26;&#x26;
      (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === &#x27;string&#x27;)) {
    if (ignoredNamespaces.override) {
      this.options.ignoredNamespaces = ignoredNamespaces.namespaces;
    } else {
      this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);
    }
  } else {
    this.options.ignoredNamespaces = this.ignoredNamespaces;
  }

  this.options.valueKey = options.valueKey || this.valueKey;
  this.options.xmlKey = options.xmlKey || this.xmlKey;
  if (options.escapeXML !== undefined) {
    this.options.escapeXML = options.escapeXML;
  } else {
    this.options.escapeXML = true;
  }
  // Allow any request headers to keep passing through
  this.options.wsdl_headers = options.wsdl_headers;
  this.options.wsdl_options = options.wsdl_options;
  if (options.httpClient) {
    this.options.httpClient = options.httpClient;
  }

  // The supplied request-object should be passed through
  if (options.request) {
    this.options.request = options.request;
  }

  var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;
  if (ignoreBaseNameSpaces !== null &#x26;&#x26; typeof ignoreBaseNameSpaces !== &#x27;undefined&#x27;) {
    this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;
  } else {
    this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;
  }

  // Works only in client
  this.options.forceSoap12Headers = options.forceSoap12Headers;
  this.options.customDeserializer = options.customDeserializer;

  if (options.overrideRootElement !== undefined) {
    this.options.overrideRootElement = options.overrideRootElement;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
concatStream = require(&#x27;concat-stream&#x27;),
uuid = require(&#x27;uuid&#x27;);

var Client = function(wsdl, endpoint, options) {
events.EventEmitter.call(this);
options = options || {};
this.wsdl = wsdl;
this.<span class="apidocCodeKeywordSpan">_initializeOptions</span>(options);
this._initializeServices(endpoint);
this.httpClient = options.httpClient || new HttpClient(options);
};
util.inherits(Client, events.EventEmitter);

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._parse" id="apidoc.element.soap.WSDL.prototype._parse">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_parse
        <span class="apidocSignatureSpan">(xml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parse = function (xml) {
  var self = this,
    p = sax.parser(true),
    stack = [],
    root = null,
    types = null,
    schema = null,
      options = self.options;

  p.onopentag = function(node) {
    var nsName = node.name;
    var attrs  = node.attributes;

    var top = stack[stack.length - 1];
    var name;
    if (top) {
      try {
        top.startElement(stack, nsName, attrs, options);
      } catch (e) {
        if (self.options.strict) {
          throw e;
        } else {
          stack.push(new Element(nsName, attrs, options));
        }
      }
    } else {
      name = splitQName(nsName).name;
      if (name === &#x27;definitions&#x27;) {
        root = new DefinitionsElement(nsName, attrs, options);
        stack.push(root);
      } else if (name === &#x27;schema&#x27;) {
        // Shim a structure in here to allow the proper objects to be created when merging back.
        root = new DefinitionsElement(&#x27;definitions&#x27;, {}, {});
        types = new TypesElement(&#x27;types&#x27;, {}, {});
        schema = new SchemaElement(nsName, attrs, options);
        types.addChild(schema);
        root.addChild(types);
        stack.push(schema);
      } else {
        throw new Error(&#x27;Unexpected root element of WSDL or include&#x27;);
      }
    }
  };

  p.onclosetag = function(name) {
    var top = stack[stack.length - 1];
    assert(top, &#x27;Unmatched close tag: &#x27; + name);

    top.endElement(stack, name);
  };

  p.write(xml).close();

  return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  p.write(xml).close();

  return root;
};

WSDL.prototype._fromXML = function(xml) {
  this.definitions = this.<span class="apidocCodeKeywordSpan">_parse</span>(xml);
  this.definitions.descriptions = {
    types:{}
  };
  this.xml = xml;
};

WSDL.prototype._fromServices = function(services) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._processNextInclude" id="apidoc.element.soap.WSDL.prototype._processNextInclude">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_processNextInclude
        <span class="apidocSignatureSpan">(includes, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processNextInclude = function (includes, callback) {
  var self = this,
    include = includes.shift(),
    options;

  if (!include)
    return callback();

  var includePath;
  if (!/^https?:/.test(self.uri) &#x26;&#x26; !/^https?:/.test(include.location)) {
    includePath = path.resolve(path.dirname(self.uri), include.location);
  } else {
    includePath = url.resolve(self.uri||&#x27;&#x27;, include.location);
  }

  options = _.assign({}, this.options);
  // follow supplied ignoredNamespaces option
  options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;
  options.WSDL_CACHE = this.WSDL_CACHE;

  open_wsdl_recursive(includePath, options, function(err, wsdl) {
    if (err) {
      return callback(err);
    }

    self._includesWsdl.push(wsdl);

    if (wsdl.definitions instanceof DefinitionsElement) {
      _.merge(self.definitions, wsdl.definitions, function(a,b) {
        return (a instanceof SchemaElement) ? a.merge(b) : undefined;
      });
    } else {
      self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include
.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);
    }
    self._processNextInclude(includes, function(err) {
      callback(err);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (wsdl.definitions instanceof DefinitionsElement) {
    _.merge(self.definitions, wsdl.definitions, function(a,b) {
      return (a instanceof SchemaElement) ? a.merge(b) : undefined;
    });
  } else {
    self.definitions.schemas[include.namespace || wsdl.definitions.$targetNamespace] = deepMerge(self.definitions.schemas[include
.namespace || wsdl.definitions.$targetNamespace], wsdl.definitions);
  }
  self.<span class="apidocCodeKeywordSpan">_processNextInclude</span>(includes, function(err) {
    callback(err);
  });
});
};

WSDL.prototype.processIncludes = function(callback) {
var schemas = this.definitions.schemas,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._splitQName" id="apidoc.element.soap.WSDL.prototype._splitQName">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_splitQName
        <span class="apidocSignatureSpan">(nsName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splitQName(nsName) {
  var i = typeof nsName === &#x27;string&#x27; ? nsName.indexOf(&#x27;:&#x27;) : -1;
  return i &#x3c; 0 ? {prefix: TNS_PREFIX, name: nsName} :
  {prefix: nsName.substring(0, i), name: nsName.substring(i + 1)};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype._xmlnsMap" id="apidoc.element.soap.WSDL.prototype._xmlnsMap">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>_xmlnsMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_xmlnsMap = function () {
  var xmlns = this.definitions.xmlns;
  var str = &#x27;&#x27;;
  for (var alias in xmlns) {
    if (alias === &#x27;&#x27; || alias === TNS_PREFIX) {
      continue;
    }
    var ns = xmlns[alias];
    switch (ns) {
      case &#x22;http://xml.apache.org/xml-soap&#x22; : // apachesoap
      case &#x22;http://schemas.xmlsoap.org/wsdl/&#x22; : // wsdl
      case &#x22;http://schemas.xmlsoap.org/wsdl/soap/&#x22; : // wsdlsoap
      case &#x22;http://schemas.xmlsoap.org/wsdl/soap12/&#x22;: // wsdlsoap12
      case &#x22;http://schemas.xmlsoap.org/soap/encoding/&#x22; : // soapenc
      case &#x22;http://www.w3.org/2001/XMLSchema&#x22; : // xsd
        continue;
    }
    if (~ns.indexOf(&#x27;http://schemas.xmlsoap.org/&#x27;)) {
      continue;
    }
    if (~ns.indexOf(&#x27;http://www.w3.org/&#x27;)) {
      continue;
    }
    if (~ns.indexOf(&#x27;http://xml.apache.org/&#x27;)) {
      continue;
    }
    str += &#x27; xmlns:&#x27; + alias + &#x27;=&#x22;&#x27; + ns + &#x27;&#x22;&#x27;;
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              outputName = methods[methodName].output.$name;
            topEls[inputName] = {&#x22;methodName&#x22;: methodName, &#x22;outputName&#x22;: outputName};
          }
        }
      }

      // prepare soap envelope xmlns definition string
      self.xmlnsInEnvelope = self.<span class="apidocCodeKeywordSpan">_xmlnsMap</span>();

      self.callback(err, self);
    });

  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.describeServices" id="apidoc.element.soap.WSDL.prototype.describeServices">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>describeServices
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describeServices = function () {
  var services = {};
  for (var name in this.services) {
    var service = this.services[name];
    services[name] = service.description(this.definitions);
  }
  return services;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Client.prototype.setEndpoint = function(endpoint) {
  this.endpoint = endpoint;
  this._initializeServices(endpoint);
};

Client.prototype.describe = function() {
  var types = this.wsdl.definitions.types;
  return this.wsdl.<span class="apidocCodeKeywordSpan">describeServices</span>();
};

Client.prototype.setSecurity = function(security) {
  this.security = security;
};

Client.prototype.setSOAPAction = function(SOAPAction) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.filterOutIgnoredNameSpace" id="apidoc.element.soap.WSDL.prototype.filterOutIgnoredNameSpace">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>filterOutIgnoredNameSpace
        <span class="apidocSignatureSpan">(ns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterOutIgnoredNameSpace = function (ns) {
  var namespace = noColonNameSpace(ns);
  return this.isIgnoredNameSpace(namespace) ? &#x27;&#x27; : namespace;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.findChildSchemaObject" id="apidoc.element.soap.WSDL.prototype.findChildSchemaObject">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findChildSchemaObject
        <span class="apidocSignatureSpan">(parameterTypeObj, childName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findChildSchemaObject = function (parameterTypeObj, childName) {
  if (!parameterTypeObj || !childName) {
    return null;
  }
  var found = null,
      i = 0,
      child,
      ref;

  if (Array.isArray(parameterTypeObj.$lookupTypes) &#x26;&#x26; parameterTypeObj.$lookupTypes.length) {
    var types = parameterTypeObj.$lookupTypes;

    for(i = 0; i &#x3c; types.length; i++) {
      var typeObj = types[i];

      if(typeObj.$name === childName) {
        found = typeObj;
        break;
      }
    }
  }

  var object = parameterTypeObj;
  if (object.$name === childName &#x26;&#x26; object.name === &#x27;element&#x27;) {
    return object;
  }
  if (object.$ref) {
    ref = splitQName(object.$ref);
    if (ref.name === childName) {
      return object;
    }
  }

  var childNsURI;
  if (object.$type) {
    var typeInfo = splitQName(object.$type);
    if (typeInfo.prefix === TNS_PREFIX) {
      childNsURI = parameterTypeObj.$targetNamespace;
    } else {
      childNsURI = this.definitions.xmlns[typeInfo.prefix];
    }
    var typeDef = this.findSchemaType(typeInfo.name, childNsURI);
    if (typeDef) {
      return this.findChildSchemaObject(typeDef, childName);
    }
  }

  if (object.children) {
    for (i = 0, child; child = object.children[i]; i++) {
      found = this.findChildSchemaObject(child, childName);
      if (found) {
        break;
      }

      if (child.$base) {
        var baseQName = splitQName(child.$base);
        var childNameSpace = baseQName.prefix === TNS_PREFIX ? &#x27;&#x27; : baseQName.prefix;
        childNsURI = this.definitions.xmlns[baseQName.prefix];

        var foundBase = this.findSchemaType(baseQName.name, childNsURI);

        if (foundBase) {
          found = this.findChildSchemaObject(foundBase, childName);

          if (found) {
            found.$baseNameSpace = childNameSpace;
            found.$type = childNameSpace + &#x27;:&#x27; + childName;
            break;
          }
        }
      }
    }

  }

  if (!found &#x26;&#x26; object.$name === childName) {
    return object;
  }

  return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      if (isFirst) {
value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);
      } else {

if (self.definitions.schemas) {
  if (schema) {
    var childSchemaObject = self.<span class="apidocCodeKeywordSpan">findChildSchemaObject</span>(schemaObject, name);
    //find sub namespace if not a primitive
    if (childSchemaObject &#x26;&#x26;
      ((childSchemaObject.$type &#x26;&#x26; (childSchemaObject.$type.indexOf(&#x27;xsd:&#x27;) === -1)) ||
      childSchemaObject.$ref || childSchemaObject.$name)) {
      /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.
       This is because in some services the child nodes do not need the baseNameSpace.
       */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.findSchemaObject" id="apidoc.element.soap.WSDL.prototype.findSchemaObject">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findSchemaObject
        <span class="apidocSignatureSpan">(nsURI, qname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSchemaObject = function (nsURI, qname) {
  if (!nsURI || !qname) {
    return null;
  }

  var def = null;

  if (this.definitions.schemas) {
    var schema = this.definitions.schemas[nsURI];
    if (schema) {
      if (qname.indexOf(&#x27;:&#x27;) !== -1) {
        qname = qname.substring(qname.indexOf(&#x27;:&#x27;) + 1, qname.length);
      }

      // if the client passed an input element which has a `$lookupType` property instead of `$type`
      // the `def` is found in `schema.elements`.
      def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];
    }
  }

  return def;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var typeURI;
  if (type.prefix === TNS_PREFIX) {
    // In case of xsi:type = &#x22;MyType&#x22;
    typeURI = xmlns[type.prefix] || xmlns.xmlns;
  } else {
    typeURI = xmlns[type.prefix];
  }
  var typeDef = self.<span class="apidocCodeKeywordSpan">findSchemaObject</span>(typeURI, type.name);
  if (typeDef) {
    xsiTypeSchema = typeDef.description(self.definitions);
  }
}

if (topSchema &#x26;&#x26; topSchema[name + &#x27;[]&#x27;]) {
  name = name + &#x27;[]&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.findSchemaType" id="apidoc.element.soap.WSDL.prototype.findSchemaType">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>findSchemaType
        <span class="apidocSignatureSpan">(name, nsURI)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSchemaType = function (name, nsURI) {
  if (!this.definitions.schemas || !name || !nsURI) {
    return null;
  }

  var schema = this.definitions.schemas[nsURI];
  if (!schema || !schema.complexTypes) {
    return null;
  }

  return schema.complexTypes[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var typeURI = schema.xmlns[typePrefix] || self.definitions.xmlns[typePrefix];
  childNsURI = typeURI;
  if (typeURI !== &#x27;http://www.w3.org/2001/XMLSchema&#x27; &#x26;&#x26; typePrefix !== TNS_PREFIX) {
    // Add the prefix/namespace mapping, but not declare it
    nsContext.addNamespace(typePrefix, typeURI);
  }
  resolvedChildSchemaObject =
    self.<span class="apidocCodeKeywordSpan">findSchemaType</span>(typeQName.name, typeURI) || childSchemaObject;
} else {
  resolvedChildSchemaObject =
    self.findSchemaObject(childNsURI, childName) || childSchemaObject;
}

if (childSchemaObject.$baseNameSpace &#x26;&#x26; this.options.ignoreBaseNameSpaces) {
  childNsPrefix = nsPrefix;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.isIgnoredNameSpace" id="apidoc.element.soap.WSDL.prototype.isIgnoredNameSpace">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>isIgnoredNameSpace
        <span class="apidocSignatureSpan">(ns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIgnoredNameSpace = function (ns) {
  return this.options.ignoredNamespaces.indexOf(ns) &#x3e; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

WSDL.prototype.isIgnoredNameSpace = function(ns) {
 return this.options.ignoredNamespaces.indexOf(ns) &#x3e; -1;
};

WSDL.prototype.filterOutIgnoredNameSpace = function(ns) {
 var namespace = noColonNameSpace(ns);
 return this.<span class="apidocCodeKeywordSpan">isIgnoredNameSpace</span>(namespace) ? &#x27;&#x27; : namespace;
};



/**
* Convert an object to XML.  This is a recursive method as it calls itself.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.objectToDocumentXML" id="apidoc.element.soap.WSDL.prototype.objectToDocumentXML">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToDocumentXML
        <span class="apidocSignatureSpan">(name, params, nsPrefix, nsURI, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectToDocumentXML = function (name, params, nsPrefix, nsURI, type) {
  var args = {};
  args[name] = params;
  var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;
  return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.objectToRpcXML(name, args, alias, ns,(input.name!==&#x22;element&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
  // pass `input.$lookupType` if `input.$type` could not be found
  message = self.wsdl.<span class="apidocCodeKeywordSpan">objectToDocumentXML</span>(input.$name, args, input.targetNSAlias, input
.targetNamespace, (input.$type || input.$lookupType));
}
xml = &#x22;&#x3c;?xml version=\&#x22;1.0\&#x22; encoding=\&#x22;utf-8\&#x22;?&#x3e;&#x22; +
  &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Envelope &#x22; +
  xmlnsSoap + &#x22; &#x22; +
  &#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
  encoding +
  this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.objectToRpcXML" id="apidoc.element.soap.WSDL.prototype.objectToRpcXML">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToRpcXML
        <span class="apidocSignatureSpan">(name, params, nsPrefix, nsURI, isParts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectToRpcXML = function (name, params, nsPrefix, nsURI, isParts) {
  var parts = [];
  var defs = this.definitions;
  var nsAttrName = &#x27;_xmlns&#x27;;

  nsPrefix = nsPrefix || findPrefix(defs.xmlns, nsURI);

  nsURI = nsURI || defs.xmlns[nsPrefix];
  nsPrefix = nsPrefix === TNS_PREFIX ? &#x27;&#x27; : (nsPrefix + &#x27;:&#x27;);

  parts.push([&#x27;&#x3c;&#x27;, nsPrefix, name, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));

  for (var key in params) {
    if (!params.hasOwnProperty(key)) {
      continue;
    }
    if (key !== nsAttrName) {
      var value = params[key];
      var prefixedKey = (isParts ? &#x27;&#x27; : nsPrefix) + key;
      parts.push([&#x27;&#x3c;&#x27;, prefixedKey, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
      parts.push((typeof value === &#x27;object&#x27;) ? this.objectToXML(value, key, nsPrefix, nsURI) : xmlEscape(value));
      parts.push([&#x27;&#x3c;/&#x27;, prefixedKey, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
    }
  }
  parts.push([&#x27;&#x3c;/&#x27;, nsPrefix, name, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
  return parts.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self.security &#x26;&#x26; self.security.addHeaders)
  self.security.addHeaders(headers);
if (self.security &#x26;&#x26; self.security.addOptions)
  self.security.addOptions(options);

if ((style === &#x27;rpc&#x27;)&#x26;&#x26; ( ( input.parts || input.name===&#x22;element&#x22; ) || args === null) ) {
  assert.ok(!style || style === &#x27;rpc&#x27;, &#x27;invalid message definition for document style binding&#x27;);
  message = self.wsdl.<span class="apidocCodeKeywordSpan">objectToRpcXML</span>(name, args, alias, ns,(input.name!==&#x22;element
&#x22; ));
  (method.inputSoap === &#x27;encoded&#x27;) &#x26;&#x26; (encoding = &#x27;soap:encodingStyle=&#x22;http://schemas.xmlsoap.org/
soap/encoding/&#x22; &#x27;);
} else {
  assert.ok(!style || style === &#x27;document&#x27;, &#x27;invalid message definition for rpc style binding&#x27;);
  // pass `input.$lookupType` if `input.$type` could not be found
  message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input.$
lookupType));
}
xml = &#x22;&#x3c;?xml version=\&#x22;1.0\&#x22; encoding=\&#x22;utf-8\&#x22;?&#x3e;&#x22; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.objectToXML" id="apidoc.element.soap.WSDL.prototype.objectToXML">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>objectToXML
        <span class="apidocSignatureSpan">(obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectToXML = function (obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {
  var self = this;
  var schema = this.definitions.schemas[nsURI];

  var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;
  if (typeof parentNsPrefix !== &#x27;undefined&#x27;) {
    //we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string
    nsPrefix = nsPrefix.current;
  }

  parentNsPrefix = noColonNameSpace(parentNsPrefix);
  if (this.isIgnoredNameSpace(parentNsPrefix)) {
    parentNsPrefix = &#x27;&#x27;;
  }

  var soapHeader = !schema;
  var qualified = schema &#x26;&#x26; schema.$elementFormDefault === &#x27;qualified&#x27;;
  var parts = [];
  var prefixNamespace = (nsPrefix || qualified) &#x26;&#x26; nsPrefix !== TNS_PREFIX;

  var xmlnsAttrib = &#x27;&#x27;;
  if (nsURI &#x26;&#x26; isFirst) {
    if(self.options.overrideRootElement &#x26;&#x26; self.options.overrideRootElement.xmlnsAttributes) {
      self.options.overrideRootElement.xmlnsAttributes.forEach(function(attribute) {
        xmlnsAttrib += &#x27; &#x27; + attribute.name + &#x27;=&#x22;&#x27; + attribute.value + &#x27;&#x22;&#x27;;
      });
    } else {
      if (prefixNamespace &#x26;&#x26; !this.isIgnoredNameSpace(nsPrefix)) {
        // resolve the prefix namespace
        xmlnsAttrib += &#x27; xmlns:&#x27; + nsPrefix + &#x27;=&#x22;&#x27; + nsURI + &#x27;&#x22;&#x27;;
      }
      // only add default namespace if the schema elementFormDefault is qualified
      if (qualified || soapHeader) xmlnsAttrib += &#x27; xmlns=&#x22;&#x27; + nsURI + &#x27;&#x22;&#x27;;
    }
  }

  if (!nsContext) {
    nsContext = new NamespaceContext();
    nsContext.declareNamespace(nsPrefix, nsURI);
  } else {
    nsContext.pushContext();
  }

  // explicitly use xmlns attribute if available
  if (xmlnsAttr &#x26;&#x26; !(self.options.overrideRootElement &#x26;&#x26; self.options.overrideRootElement.xmlnsAttributes)) {
    xmlnsAttrib = xmlnsAttr;
  }

  var ns = &#x27;&#x27;;

  if (self.options.overrideRootElement &#x26;&#x26; isFirst) {
    ns = self.options.overrideRootElement.namespace;
  } else if (prefixNamespace &#x26;&#x26; (qualified || isFirst || soapHeader) &#x26;&#x26; !this.isIgnoredNameSpace(nsPrefix)) {
    ns = nsPrefix;
  }

  var i, n;
  // start building out XML string.
  if (Array.isArray(obj)) {
    for (i = 0, n = obj.length; i &#x3c; n; i++) {
      var item = obj[i];
      var arrayAttr = self.processAttributes(item, nsContext),
          correctOuterNsPrefix = parentNsPrefix || ns; //using the parent namespace prefix if given

      parts.push([&#x27;&#x3c;&#x27;, appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
      parts.push(self.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext));
      parts.push([&#x27;&#x3c;/&#x27;, appendColon(correctOuterNsPrefix), name, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
    }
  } else if (typeof obj === &#x27;object&#x27;) {
    for (name in obj) {
      if (!obj.hasOwnProperty(name)) continue;
      //don&#x27;t process attributes as element
      if (name === self.options.attributesKey) {
        continue;
      }
      //Its the value of a xml object. Return it directly.
      if (name === self.options.xmlKey){
        nsContext.popContext();
        return obj[name];
      }
      //Its the value of an item. Return it directly.
      if (name === self.options.valueKey) {
        nsContext.popContext();
        return xmlEscape(obj[name]);
      }

      var child = obj[name];
      if (typeof child === &#x27;undefined&#x27;) {
        continue;
      }

      var attr = self.processAttributes(child, nsContext);

      var value = &#x27;&#x27;;
      var nonSubNameSpace = &#x27;&#x27;;
      var emptyNonSubNameSpace = false;

      var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);
      if (nameWithNsRegex) {
        nonSubNameSpace = nameWithNsRegex[1] + &#x27;:&#x27;;
        name = nameWithNsRegex[2];
      } else if(name[0] === &#x27;:&#x27;){
        emptyNonSubNameSpace = true;
        name = name.substr(1);
      }

      if (isFirst) {
        value = self.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);
      } else {

        if (self.definitions.schemas) {
          if (schema) {
            var childSchemaObject = sel ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
util.inherits(Client, events.EventEmitter);

Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
  this.soapHeaders = [];
}
if (typeof soapHeader === &#x27;object&#x27;) {
  soapHeader = this.wsdl.<span class="apidocCodeKeywordSpan">objectToXML</span>(soapHeader, name, namespace, xmlns, true);
}
return this.soapHeaders.push(soapHeader) - 1;
};

Client.prototype.changeSoapHeader = function(index, soapHeader, name, namespace, xmlns) {
if (!this.soapHeaders) {
  this.soapHeaders = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.onReady" id="apidoc.element.soap.WSDL.prototype.onReady">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>onReady
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onReady = function (callback) {
  if (callback)
    this.callback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.path = path;
this.services = services;
this.wsdl = wsdl;
this.suppressStack = options &#x26;&#x26; options.suppressStack;

if (path[path.length - 1] !== &#x27;/&#x27;)
  path += &#x27;/&#x27;;
wsdl.<span class="apidocCodeKeywordSpan">onReady</span>(function (err) {
  if (typeof server.route === &#x27;function&#x27; &#x26;&#x26; typeof server.use === &#x27;function&#x27;) {
    //handle only the required URL path for express server
    server.route(path).all(function (req, res, next) {
      if (typeof self.authorizeConnection === &#x27;function&#x27;) {
        if (!self.authorizeConnection(req)) {
          res.end();
          return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.processAttributes" id="apidoc.element.soap.WSDL.prototype.processAttributes">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>processAttributes
        <span class="apidocSignatureSpan">(child, nsContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processAttributes = function (child, nsContext) {
  var attr = &#x27;&#x27;;

  if(child === null) {
    child = [];
  }

  var attrObj = child[this.options.attributesKey];
  if (attrObj &#x26;&#x26; attrObj.xsi_type) {
    var xsiType = attrObj.xsi_type;

    var prefix = xsiType.prefix || xsiType.namespace;
    // Generate a new namespace for complex extension if one not provided
    if (!prefix) {
      prefix = nsContext.registerNamespace(xsiType.xmlns);
    } else {
      nsContext.declareNamespace(prefix, xsiType.xmlns);
    }
    xsiType.prefix = prefix;
  }


  if (attrObj) {
    for (var attrKey in attrObj) {
      //handle complex extension separately
      if (attrKey === &#x27;xsi_type&#x27;) {
        var attrValue = attrObj[attrKey];
        attr += &#x27; xsi:type=&#x22;&#x27; + attrValue.prefix + &#x27;:&#x27; + attrValue.type + &#x27;&#x22;&#x27;;
        attr += &#x27; xmlns:&#x27; + attrValue.prefix + &#x27;=&#x22;&#x27; + attrValue.xmlns + &#x27;&#x22;&#x27;;

        continue;
      } else {
        attr += &#x27; &#x27; + attrKey + &#x27;=&#x22;&#x27; + xmlEscape(attrObj[attrKey]) + &#x27;&#x22;&#x27;;
      }
    }
  }

  return attr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var i, n;
// start building out XML string.
if (Array.isArray(obj)) {
  for (i = 0, n = obj.length; i &#x3c; n; i++) {
    var item = obj[i];
    var arrayAttr = self.<span class="apidocCodeKeywordSpan">processAttributes</span>(item, nsContext),
        correctOuterNsPrefix = parentNsPrefix || ns; //using the parent namespace prefix if given

    parts.push([&#x27;&#x3c;&#x27;, appendColon(correctOuterNsPrefix), name, arrayAttr, xmlnsAttrib, &#x27;&#x3e;&#x27;].join(&#
x27;&#x27;));
    parts.push(self.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext));
    parts.push([&#x27;&#x3c;/&#x27;, appendColon(correctOuterNsPrefix), name, &#x27;&#x3e;&#x27;].join(&#x27;&#x27;));
  }
} else if (typeof obj === &#x27;object&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.processIncludes" id="apidoc.element.soap.WSDL.prototype.processIncludes">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>processIncludes
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processIncludes = function (callback) {
  var schemas = this.definitions.schemas,
    includes = [];

  for (var ns in schemas) {
    var schema = schemas[ns];
    includes = includes.concat(schema.includes || []);
  }

  this._processNextInclude(includes, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.nextTick(function() {
    try {
fromFunc.call(self, definition);
    } catch (e) {
return self.callback(e.message);
    }

    self.<span class="apidocCodeKeywordSpan">processIncludes</span>(function(err) {
var name;
if (err) {
  return self.callback(err);
}

self.definitions.deleteFixedAttrs();
var services = self.services = self.definitions.services;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.toXML" id="apidoc.element.soap.WSDL.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>toXML
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function () {
  return this.xml || &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.WSDL.prototype.xmlToObject" id="apidoc.element.soap.WSDL.prototype.xmlToObject">
        function <span class="apidocSignatureSpan">soap.WSDL.prototype.</span>xmlToObject
        <span class="apidocSignatureSpan">(xml, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xmlToObject = function (xml, callback) {
  var self = this;
  var p = typeof callback === &#x27;function&#x27; ? {} : sax.parser(true);
  var objectName = null;
  var root = {};
  var schema = {
    Envelope: {
      Header: {
        Security: {
          UsernameToken: {
            Username: &#x27;string&#x27;,
            Password: &#x27;string&#x27;
          }
        }
      },
      Body: {
        Fault: {
          faultcode: &#x27;string&#x27;,
          faultstring: &#x27;string&#x27;,
          detail: &#x27;string&#x27;
        }
      }
    }
  };
  var stack = [{name: null, object: root, schema: schema}];
  var xmlns = {};

  var refs = {}, id; // {id:{hrefs:[],obj:}, ...}

  p.onopentag = function(node) {
    var nsName = node.name;
    var attrs  = node.attributes;

    var name = splitQName(nsName).name,
      attributeName,
      top = stack[stack.length - 1],
      topSchema = top.schema,
      elementAttributes = {},
      hasNonXmlnsAttribute = false,
      hasNilAttribute = false,
      obj = {};
    var originalName = name;

    if (!objectName &#x26;&#x26; top.name === &#x27;Body&#x27; &#x26;&#x26; name !== &#x27;Fault&#x27;) {
      var message = self.definitions.messages[name];
      // Support RPC/literal messages where response body contains one element named
      // after the operation + &#x27;Response&#x27;. See http://www.w3.org/TR/wsdl#_names
      if (!message) {
        // Determine if this is request or response
        var isInput = false;
        var isOutput = false;
        if ((/Response$/).test(name)) {
          isOutput = true;
          name = name.replace(/Response$/, &#x27;&#x27;);
        } else if ((/Request$/).test(name)) {
          isInput = true;
          name = name.replace(/Request$/, &#x27;&#x27;);
        } else if ((/Solicit$/).test(name)) {
          isInput = true;
          name = name.replace(/Solicit$/, &#x27;&#x27;);
        }
        // Look up the appropriate message as given in the portType&#x27;s operations
        var portTypes = self.definitions.portTypes;
        var portTypeNames = Object.keys(portTypes);
        // Currently this supports only one portType definition.
        var portType = portTypes[portTypeNames[0]];
        if (isInput) {
          name = portType.methods[name].input.$name;
        } else {
          name = portType.methods[name].output.$name;
        }
        message = self.definitions.messages[name];
        // &#x27;cache&#x27; this alias to speed future lookups
        self.definitions.messages[originalName] = self.definitions.messages[name];
      }

      topSchema = message.description(self.definitions);
      objectName = originalName;
    }

    if (attrs.href) {
      id = attrs.href.substr(1);
      if (!refs[id]) {
        refs[id] = {hrefs: [], obj: null};
      }
      refs[id].hrefs.push({par: top.object, key: name, obj: obj});
    }
    if (id = attrs.id) {
      if (!refs[id]) {
        refs[id] = {hrefs: [], obj: null};
      }
    }

    //Handle element attributes
    for (attributeName in attrs) {
      if (/^xmlns:|^xmlns$/.test(attributeName)) {
        xmlns[splitQName(attributeName).name] = attrs[attributeName];
        continue;
      }
      hasNonXmlnsAttribute = true;
      elementAttributes[attributeName] = attrs[attributeName];
    }

    for(attributeName in elementAttributes){
      var res = splitQName(attributeName);
      if (res.name === &#x27;nil&#x27; &#x26;&#x26; xmlns[res.prefix] === &#x27;http://www.w3.org/2001/XMLSchema-instance&#x27;) {
        hasNilAttribute = true;
        break;
      }
    }

    if (hasNonXmlnsAttribute) {
      obj[self.options.attributesKey] = elementAttributes;
    }

    // Pick up the schema for the type specified in element&#x27;s xsi:type attribute.
    var xsiTypeSchema;
    var xsiType = elementAttributes[&#x27;xsi:type&#x27;];
    if (xsiType) {
      var type = splitQName(xsiType);
      var typeURI;
      if (type.prefix === TNS_PREFIX) {
        // In case of xsi:type = &#x22;MyType&#x22;
        typeURI = xmlns[type.prefix] || xmlns.xmlns;
      } else {
        typeURI = xmlns[type.prefix];
      }
      var typeDef = self.findSchemaObject( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return parseSync(body, response);

}));
return;
      }

      self.wsdl.<span class="apidocCodeKeywordSpan">xmlToObject</span>(response, function (error, obj) {
self.lastResponse = response;
self.lastResponseHeaders = response &#x26;&#x26; response.headers;
self.lastElapsedTime = Date.now() - startTime;
self.emit(&#x27;response&#x27;, &#x27;&#x3c;stream&#x3e;&#x27;, response, eid);

if (error) {
  error.response = response;
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSSecurity" id="apidoc.module.soap.WSSecurity">module soap.WSSecurity</a></h1>


    <h2>
        <a href="#apidoc.element.soap.WSSecurity.WSSecurity" id="apidoc.element.soap.WSSecurity.WSSecurity">
        function <span class="apidocSignatureSpan">soap.</span>WSSecurity
        <span class="apidocSignatureSpan">(username, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurity(username, password, options) {
  options = options || {};
  this._username = username;
  this._password = password;
  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = &#x27;PasswordText
&#x27;, hasTimeStamp = true
  if (typeof options === &#x27;string&#x27;) {
    this._passwordType = options ? options : &#x27;PasswordText&#x27;;
    options = {};
  } else {
    this._passwordType = options.passwordType ? options.passwordType : &#x27;PasswordText&#x27;;
  }

  if (validPasswordTypes.indexOf(this._passwordType) === -1) {
    this._passwordType = &#x27;PasswordText&#x27;;
  }

  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === &#x27;boolean&#x27; ? !!options.hasTimeStamp : true;
  /*jshint eqnull:true */
  if (options.hasNonce != null) {
    this._hasNonce = !!options.hasNonce;
  }
  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === &#x27;boolean&#x27; ? !!options.hasTokenCreated :
true;
  if (options.actor != null) {
    this._actor = options.actor;
  }
  if (options.mustUnderstand != null) {
    this._mustUnderstand = !!options.mustUnderstand;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSSecurity.prototype" id="apidoc.module.soap.WSSecurity.prototype">module soap.WSSecurity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.WSSecurity.prototype.toXML" id="apidoc.element.soap.WSSecurity.prototype.toXML">
        function <span class="apidocSignatureSpan">soap.WSSecurity.prototype.</span>toXML
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toXML = function () {
  // avoid dependency on date formatting libraries
  function getDate(d) {
    function pad(n) {
      return n &#x3c; 10 ? &#x27;0&#x27; + n : n;
    }
    return d.getUTCFullYear() + &#x27;-&#x27;
      + pad(d.getUTCMonth() + 1) + &#x27;-&#x27;
      + pad(d.getUTCDate()) + &#x27;T&#x27;
      + pad(d.getUTCHours()) + &#x27;:&#x27;
      + pad(d.getUTCMinutes()) + &#x27;:&#x27;
      + pad(d.getUTCSeconds()) + &#x27;Z&#x27;;
  }
  var now = new Date();
  var created = getDate(now);
  var timeStampXml = &#x27;&#x27;;
  if (this._hasTimeStamp) {
    var expires = getDate( new Date(now.getTime() + (1000 * 600)) );
    timeStampXml = &#x22;&#x3c;wsu:Timestamp wsu:Id=\&#x22;Timestamp-&#x22;+created+&#x22;\&#x22;&#x3e;&#x22; +
      &#x22;&#x3c;wsu:Created&#x3e;&#x22;+created+&#x22;&#x3c;/wsu:Created&#x3e;&#x22; +
      &#x22;&#x3c;wsu:Expires&#x3e;&#x22;+expires+&#x22;&#x3c;/wsu:Expires&#x3e;&#x22; +
      &#x22;&#x3c;/wsu:Timestamp&#x3e;&#x22;;
  }

  var password, nonce;
  if (this._hasNonce || this._passwordType !== &#x27;PasswordText&#x27;) {
    // nonce = base64 ( sha1 ( created + random ) )
    var nHash = crypto.createHash(&#x27;sha1&#x27;);
    nHash.update(created + Math.random());
    nonce = nHash.digest(&#x27;base64&#x27;);
  }
  if (this._passwordType === &#x27;PasswordText&#x27;) {
    password = &#x22;&#x3c;wsse:Password Type=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\&#x22;&#x3e;&#x22; + this._password + &#x22;&#x3c;/wsse:Password&#x3e;&#x22;;
    if (nonce) {
      password += &#x22;&#x3c;wsse:Nonce EncodingType=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#
Base64Binary\&#x22;&#x3e;&#x22; + nonce + &#x22;&#x3c;/wsse:Nonce&#x3e;&#x22;;
    }
  } else {
    password = &#x22;&#x3c;wsse:Password Type=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\&#x22;&#x3e;&#x22; + passwordDigest(nonce, created, this._password) + &#x22;&#x3c;/wsse:Password&#x3e;&#x22; +
      &#x22;&#x3c;wsse:Nonce EncodingType=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\&#x22;&#x3e;&#x22; + nonce + &#x22;&#x3c;/wsse:Nonce&#x3e;&#x22;;
  }

  return &#x22;&#x3c;wsse:Security &#x22; + (this._actor ? &#x22;soap:actor=\&#x22;&#x22; + this._actor + &#x22;\&#x22; &#x22; : &#x22;&#x22;) +
    (this._mustUnderstand ? &#x22;soap:mustUnderstand=\&#x22;1\&#x22; &#x22; : &#x22;&#x22;) +
    &#x22;xmlns:wsse=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\&#x22; xmlns:wsu=\&#x22;http://docs.oasis
-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\&#x22;&#x3e;&#x22; +
    timeStampXml +
    &#x22;&#x3c;wsse:UsernameToken xmlns:wsu=\&#x22;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\&#x22; wsu:Id
=\&#x22;SecurityToken-&#x22; + created + &#x22;\&#x22;&#x3e;&#x22; +
    &#x22;&#x3c;wsse:Username&#x3e;&#x22; + this._username + &#x22;&#x3c;/wsse:Username&#x3e;&#x22; +
    password +
    (this._hasTokenCreated ? &#x22;&#x3c;wsu:Created&#x3e;&#x22; + created + &#x22;&#x3c;/wsu:Created&#x3e;&#x22; : &#x22;&#x22;) +
    &#x22;&#x3c;/wsse:UsernameToken&#x3e;&#x22; +
    &#x22;&#x3c;/wsse:Security&#x3e;&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;xmlns:xsi=\&#x22;http://www.w3.org/2001/XMLSchema-instance\&#x22; &#x22; +
encoding +
this.wsdl.xmlnsInEnvelope + &#x27;&#x3e;&#x27; +
((self.soapHeaders || self.security) ?
  (
    &#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22; +
    (self.soapHeaders ? self.soapHeaders.join(&#x22;\n&#x22;) : &#x22;&#x22;) +
    (self.security &#x26;&#x26; !self.security.postProcess ? self.security.<span class="apidocCodeKeywordSpan">toXML</span>() : &#
x22;&#x22;) +
    &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Header&#x3e;&#x22;
  )
  :
    &#x27;&#x27;
  ) +
&#x22;&#x3c;&#x22; + envelopeKey + &#x22;:Body&#x22; +
(self.bodyAttributes ? self.bodyAttributes.join(&#x27; &#x27;) : &#x27;&#x27;) +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSSecurityCert" id="apidoc.module.soap.WSSecurityCert">module soap.WSSecurityCert</a></h1>


    <h2>
        <a href="#apidoc.element.soap.WSSecurityCert.WSSecurityCert" id="apidoc.element.soap.WSSecurityCert.WSSecurityCert">
        function <span class="apidocSignatureSpan">soap.</span>WSSecurityCert
        <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurityCert(privatePEM, publicP12PEM, password, encoding) {
  if (!ursa) {
    throw new Error(&#x27;Module ursa must be installed to use WSSecurityCert&#x27;);
  }
  this.privateKey = ursa.createPrivateKey(privatePEM, password, encoding);
  this.publicP12PEM = publicP12PEM.toString().replace(&#x27;-----BEGIN CERTIFICATE-----&#x27;, &#x27;&#x27;).replace(&#x27;-----END CERTIFICATE-----&#x27;, &#x27;&#x27;).
replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;);

  this.signer = new SignedXml();
  this.signer.signingKey = this.privateKey.toPrivatePem();
  this.x509Id = &#x22;x509-&#x22; + generateId();

  var _this = this;
  this.signer.keyInfoProvider = {};
  this.signer.keyInfoProvider.getKeyInfo = function (key) {
    return wsseSecurityTokenTemplate({ x509Id: _this.x509Id });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

WS-Security X509 Certificate support.

``` javascript
  var privateKey = fs.readFileSync(privateKeyPath);
  var publicKey = fs.readFileSync(publicKeyPath);
  var password = &#x27;&#x27;; // optional password
  var wsSecurity = new soap.<span class="apidocCodeKeywordSpan">WSSecurityCert</span>(privateKey, publicKey, password, &#x27;utf8
&#x27;);
  client.setSecurity(wsSecurity);
```

_Note_: Optional dependency &#x27;ursa&#x27; is required to be installed successfully when WSSecurityCert is used.

## Handling XML Attributes, Value and XML (wsdlOptions).
Sometimes it is necessary to override the default behaviour of `node-soap` in order to deal with the special requirements
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.WSSecurityCert.prototype" id="apidoc.module.soap.WSSecurityCert.prototype">module soap.WSSecurityCert.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.WSSecurityCert.prototype.postProcess" id="apidoc.element.soap.WSSecurityCert.prototype.postProcess">
        function <span class="apidocSignatureSpan">soap.WSSecurityCert.prototype.</span>postProcess
        <span class="apidocSignatureSpan">(xml, envelopeKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postProcess = function (xml, envelopeKey) {
  this.created = generateCreated();
  this.expires = generateExpires();

  var secHeader = wsseSecurityHeaderTemplate({
    binaryToken: this.publicP12PEM,
    created: this.created,
    expires: this.expires,
    id: this.x509Id
  });

  var xmlWithSec = insertStr(secHeader, xml, xml.indexOf(&#x27;&#x3c;/soap:Header&#x3e;&#x27;));

  var references = [&#x22;http://www.w3.org/2000/09/xmldsig#enveloped-signature&#x22;,
    &#x22;http://www.w3.org/2001/10/xml-exc-c14n#&#x22;];

  this.signer.addReference(&#x22;//*[name(.)=&#x27;&#x22; + envelopeKey + &#x22;:Body&#x27;]&#x22;, references);
  this.signer.addReference(&#x22;//*[name(.)=&#x27;wsse:Security&#x27;]/*[local-name(.)=&#x27;Timestamp&#x27;]&#x22;, references);

  this.signer.computeSignature(xmlWithSec);

  return insertStr(this.signer.getSignatureXml(), xmlWithSec, xmlWithSec.indexOf(&#x27;&#x3c;/wsse:Security&#x3e;&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  (self.security &#x26;&#x26; self.security.postProcess ? &#x27; Id=&#x22;_0&#x22;&#x27; : &#x27;&#x27;) +
  &#x22;&#x3e;&#x22; +
  message +
  &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Body&#x3e;&#x22; +
  &#x22;&#x3c;/&#x22; + envelopeKey + &#x22;:Envelope&#x3e;&#x22;;

if(self.security &#x26;&#x26; self.security.postProcess){
  xml = self.security.<span class="apidocCodeKeywordSpan">postProcess</span>(xml, envelopeKey);
}

self.lastMessage = message;
self.lastRequest = xml;
self.lastEndpoint = location;

var eid = options.exchangeId || uuid.v4();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.client" id="apidoc.module.soap.client">module soap.client</a></h1>


    <h2>
        <a href="#apidoc.element.soap.client.Client" id="apidoc.element.soap.client.Client">
        function <span class="apidocSignatureSpan">soap.client.</span>Client
        <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (wsdl, endpoint, options) {
  events.EventEmitter.call(this);
  options = options || {};
  this.wsdl = wsdl;
  this._initializeOptions(options);
  this._initializeServices(endpoint);
  this.httpClient = options.httpClient || new HttpClient(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.nscontext" id="apidoc.module.soap.nscontext">module soap.nscontext</a></h1>


    <h2>
        <a href="#apidoc.element.soap.nscontext.nscontext" id="apidoc.element.soap.nscontext.nscontext">
        function <span class="apidocSignatureSpan">soap.</span>nscontext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NamespaceContext() {
  if (!(this instanceof NamespaceContext)) {
    return new NamespaceContext();
  }
  this.scopes = [];
  this.pushContext();
  this.prefixCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.nscontext.prototype" id="apidoc.module.soap.nscontext.prototype">module soap.nscontext.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.addNamespace" id="apidoc.element.soap.nscontext.prototype.addNamespace">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>addNamespace
        <span class="apidocSignatureSpan">(prefix, nsUri, localOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addNamespace = function (prefix, nsUri, localOnly) {
  if (this.getNamespaceURI(prefix, localOnly) === nsUri) {
    return false;
  }
  if (this.currentScope) {
    this.currentScope.namespaces[prefix] = {
      uri: nsUri,
      prefix: prefix,
      declared: false
    };
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     prefix = &#x27;ns&#x27; + (++this.prefixCount);
     if (!this.getNamespaceURI(prefix)) {
       // The prefix is not used
       break;
     }
   }
 }
 this.<span class="apidocCodeKeywordSpan">addNamespace</span>(prefix, nsUri, true);
 return prefix;
};

/**
* Declare a namespace prefix/uri mapping
* @param {String} prefix Namespace prefix
* @param {String} nsUri Namespace URI
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.declareNamespace" id="apidoc.element.soap.nscontext.prototype.declareNamespace">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>declareNamespace
        <span class="apidocSignatureSpan">(prefix, nsUri)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareNamespace = function (prefix, nsUri) {
  if (this.currentScope) {
    var mapping = this.currentScope.getNamespaceMapping(prefix);
    if (mapping &#x26;&#x26; mapping.uri === nsUri &#x26;&#x26; mapping.declared) {
      return false;
    }
    this.currentScope.namespaces[prefix] = {
      uri: nsUri,
      prefix: prefix,
      declared: true
    };
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // only add default namespace if the schema elementFormDefault is qualified
    if (qualified || soapHeader) xmlnsAttrib += &#x27; xmlns=&#x22;&#x27; + nsURI + &#x27;&#x22;&#x27;;
  }
}

if (!nsContext) {
  nsContext = new NamespaceContext();
  nsContext.<span class="apidocCodeKeywordSpan">declareNamespace</span>(nsPrefix, nsURI);
} else {
  nsContext.pushContext();
}

// explicitly use xmlns attribute if available
if (xmlnsAttr &#x26;&#x26; !(self.options.overrideRootElement &#x26;&#x26; self.options.overrideRootElement.xmlnsAttributes)) {
  xmlnsAttrib = xmlnsAttr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.getNamespaceURI" id="apidoc.element.soap.nscontext.prototype.getNamespaceURI">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>getNamespaceURI
        <span class="apidocSignatureSpan">(prefix, localOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNamespaceURI = function (prefix, localOnly) {
  return this.currentScope &#x26;&#x26; this.currentScope.getNamespaceURI(prefix, localOnly);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return &#x27;http://www.w3.org/2000/xmlns/&#x27;;
    default:
      var nsUri = this.namespaces[prefix];
      /*jshint -W116 */
      if (nsUri != null) {
        return nsUri.uri;
      } else if (!localOnly &#x26;&#x26; this.parent) {
        return this.parent.<span class="apidocCodeKeywordSpan">getNamespaceURI</span>(prefix);
      } else {
        return null;
      }
  }
};

NamespaceScope.prototype.getNamespaceMapping = function(prefix) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.getPrefix" id="apidoc.element.soap.nscontext.prototype.getPrefix">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>getPrefix
        <span class="apidocSignatureSpan">(nsUri, localOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrefix = function (nsUri, localOnly) {
  return this.currentScope &#x26;&#x26; this.currentScope.getPrefix(nsUri, localOnly);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
      for (var p in this.namespaces) {
        if (this.namespaces[p].uri === nsUri) {
          return p;
        }
      }
      if (!localOnly &#x26;&#x26; this.parent) {
        return this.parent.<span class="apidocCodeKeywordSpan">getPrefix</span>(nsUri);
      } else {
        return null;
      }
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.popContext" id="apidoc.element.soap.nscontext.prototype.popContext">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>popContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">popContext = function () {
  var scope = this.scopes.pop();
  if (scope) {
    this.currentScope = scope.parent;
  } else {
    this.currentScope = null;
  }
  return scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!obj.hasOwnProperty(name)) continue;
//don&#x27;t process attributes as element
if (name === self.options.attributesKey) {
  continue;
}
//Its the value of a xml object. Return it directly.
if (name === self.options.xmlKey){
  nsContext.<span class="apidocCodeKeywordSpan">popContext</span>();
  return obj[name];
}
//Its the value of an item. Return it directly.
if (name === self.options.valueKey) {
  nsContext.popContext();
  return xmlEscape(obj[name]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.pushContext" id="apidoc.element.soap.nscontext.prototype.pushContext">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>pushContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushContext = function () {
  var scope = new NamespaceScope(this.currentScope);
  this.scopes.push(scope);
  this.currentScope = scope;
  return scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @constructor
*/
function NamespaceContext() {
 if (!(this instanceof NamespaceContext)) {
   return new NamespaceContext();
 }
 this.scopes = [];
 this.<span class="apidocCodeKeywordSpan">pushContext</span>();
 this.prefixCount = 0;
}

/**
* Look up the namespace URI by prefix
* @param {String} prefix Namespace prefix
* @param {Boolean} [localOnly] Search current scope only
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.nscontext.prototype.registerNamespace" id="apidoc.element.soap.nscontext.prototype.registerNamespace">
        function <span class="apidocSignatureSpan">soap.nscontext.prototype.</span>registerNamespace
        <span class="apidocSignatureSpan">(nsUri)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerNamespace = function (nsUri) {
  var prefix = this.getPrefix(nsUri);
  if (prefix) {
    // If the namespace has already mapped to a prefix
    return prefix;
  } else {
    // Try to generate a unique namespace
    while (true) {
      prefix = &#x27;ns&#x27; + (++this.prefixCount);
      if (!this.getNamespaceURI(prefix)) {
        // The prefix is not used
        break;
      }
    }
  }
  this.addNamespace(prefix, nsUri, true);
  return prefix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var elementQName = childSchemaObject.$ref || childSchemaObject.$name;
if (elementQName) {
  elementQName = splitQName(elementQName);
  childName = elementQName.name;
  if (elementQName.prefix === TNS_PREFIX) {
    // Local element
    childNsURI = childSchemaObject.$targetNamespace;
    childNsPrefix = nsContext.<span class="apidocCodeKeywordSpan">registerNamespace</span>(childNsURI);
    if (this.isIgnoredNameSpace(childNsPrefix)) {
      childNsPrefix = nsPrefix;
    }
  } else {
    childNsPrefix = elementQName.prefix;
    if (this.isIgnoredNameSpace(childNsPrefix)) {
      childNsPrefix = nsPrefix;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.security" id="apidoc.module.soap.security">module soap.security</a></h1>


    <h2>
        <a href="#apidoc.element.soap.security.BasicAuthSecurity" id="apidoc.element.soap.security.BasicAuthSecurity">
        function <span class="apidocSignatureSpan">soap.security.</span>BasicAuthSecurity
        <span class="apidocSignatureSpan">(username, password, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BasicAuthSecurity(username, password, defaults) {
  this._username = username;
  this._password = password;
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as well.  The interface is quite simple. Each protocol defines 2 methods:
* `addOptions` - a method that accepts an options arg that is eventually passed directly to `request`
* `toXML` - a method that returns a string of XML.

### BasicAuthSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BasicAuthSecurity</span>(&#x27;username&#x27;, &#x27;password&#
x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.BearerSecurity(&#x27;token&#x27;));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.security.BearerSecurity" id="apidoc.element.soap.security.BearerSecurity">
        function <span class="apidocSignatureSpan">soap.security.</span>BearerSecurity
        <span class="apidocSignatureSpan">(token, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BearerSecurity(token, defaults) {
	this._token = token;
	this.defaults = {};
	_.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` javascript
  client.setSecurity(new soap.BasicAuthSecurity(&#x27;username&#x27;, &#x27;password&#x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BearerSecurity</span>(&#x27;token&#x27;));
```

### ClientSSLSecurity

_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.security.ClientSSLSecurity" id="apidoc.element.soap.security.ClientSSLSecurity">
        function <span class="apidocSignatureSpan">soap.security.</span>ClientSSLSecurity
        <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurity(key, cert, ca, defaults) {
  if (key) {
    if(Buffer.isBuffer(key)) {
      this.key = key;
    } else if (typeof key === &#x27;string&#x27;) {
      this.key = fs.readFileSync(key);
    } else {
      throw new Error(&#x27;key should be a buffer or a string!&#x27;);
    }
  }

  if (cert) {
    if(Buffer.isBuffer(cert)) {
      this.cert = cert;
    } else if (typeof cert === &#x27;string&#x27;) {
      this.cert = fs.readFileSync(cert);
    } else {
      throw new Error(&#x27;cert should be a buffer or a string!&#x27;);
    }
  }

  if (ca) {
    if(Buffer.isBuffer(ca) || Array.isArray(ca)) {
      this.ca = ca;
    } else if (typeof ca === &#x27;string&#x27;) {
      this.ca = fs.readFileSync(ca);
    } else {
      defaults = ca;
      this.ca = null;
    }
  }

  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
* `strictSSL: false`
* `secureOptions: constants.SSL_OP_NO_TLSv1_2` (this is likely needed for node &#x3e;= 10.0)

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">ClientSSLSecurity</span>(
    &#x27;/path/to/key&#x27;
    , &#x27;/path/to/cert&#x27;
    , {/*default request options*/}
  ));
```

### WSSecurity
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.security.ClientSSLSecurityPFX" id="apidoc.element.soap.security.ClientSSLSecurityPFX">
        function <span class="apidocSignatureSpan">soap.security.</span>ClientSSLSecurityPFX
        <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurityPFX(pfx, passphrase, defaults) {
  if (typeof passphrase === &#x27;object&#x27;) {
    defaults = passphrase;
  }
  if (pfx) {
    if (Buffer.isBuffer(pfx)) {
      this.pfx = pfx;
    } else if (typeof pfx === &#x27;string&#x27;) {
      this.pfx = fs.readFileSync(pfx);
    } else {
      throw new Error(&#x27;supplied pfx file should be a buffer or a file location&#x27;);
    }
  }

  if (passphrase) {
    if (typeof passphrase === &#x27;string&#x27;) {
      this.passphrase = passphrase;
    }
  }
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.security.WSSecurity" id="apidoc.element.soap.security.WSSecurity">
        function <span class="apidocSignatureSpan">soap.security.</span>WSSecurity
        <span class="apidocSignatureSpan">(username, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurity(username, password, options) {
  options = options || {};
  this._username = username;
  this._password = password;
  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = &#x27;PasswordText
&#x27;, hasTimeStamp = true
  if (typeof options === &#x27;string&#x27;) {
    this._passwordType = options ? options : &#x27;PasswordText&#x27;;
    options = {};
  } else {
    this._passwordType = options.passwordType ? options.passwordType : &#x27;PasswordText&#x27;;
  }

  if (validPasswordTypes.indexOf(this._passwordType) === -1) {
    this._passwordType = &#x27;PasswordText&#x27;;
  }

  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === &#x27;boolean&#x27; ? !!options.hasTimeStamp : true;
  /*jshint eqnull:true */
  if (options.hasNonce != null) {
    this._hasNonce = !!options.hasNonce;
  }
  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === &#x27;boolean&#x27; ? !!options.hasTokenCreated :
true;
  if (options.actor != null) {
    this._actor = options.actor;
  }
  if (options.mustUnderstand != null) {
    this._mustUnderstand = !!options.mustUnderstand;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.security.WSSecurityCert" id="apidoc.element.soap.security.WSSecurityCert">
        function <span class="apidocSignatureSpan">soap.security.</span>WSSecurityCert
        <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurityCert(privatePEM, publicP12PEM, password, encoding) {
  if (!ursa) {
    throw new Error(&#x27;Module ursa must be installed to use WSSecurityCert&#x27;);
  }
  this.privateKey = ursa.createPrivateKey(privatePEM, password, encoding);
  this.publicP12PEM = publicP12PEM.toString().replace(&#x27;-----BEGIN CERTIFICATE-----&#x27;, &#x27;&#x27;).replace(&#x27;-----END CERTIFICATE-----&#x27;, &#x27;&#x27;).
replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;);

  this.signer = new SignedXml();
  this.signer.signingKey = this.privateKey.toPrivatePem();
  this.x509Id = &#x22;x509-&#x22; + generateId();

  var _this = this;
  this.signer.keyInfoProvider = {};
  this.signer.keyInfoProvider.getKeyInfo = function (key) {
    return wsseSecurityTokenTemplate({ x509Id: _this.x509Id });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

WS-Security X509 Certificate support.

``` javascript
  var privateKey = fs.readFileSync(privateKeyPath);
  var publicKey = fs.readFileSync(publicKeyPath);
  var password = &#x27;&#x27;; // optional password
  var wsSecurity = new soap.<span class="apidocCodeKeywordSpan">WSSecurityCert</span>(privateKey, publicKey, password, &#x27;utf8
&#x27;);
  client.setSecurity(wsSecurity);
```

_Note_: Optional dependency &#x27;ursa&#x27; is required to be installed successfully when WSSecurityCert is used.

## Handling XML Attributes, Value and XML (wsdlOptions).
Sometimes it is necessary to override the default behaviour of `node-soap` in order to deal with the special requirements
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.server" id="apidoc.module.soap.server">module soap.server</a></h1>


    <h2>
        <a href="#apidoc.element.soap.server.Server" id="apidoc.element.soap.server.Server">
        function <span class="apidocSignatureSpan">soap.server.</span>Server
        <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (server, path, services, wsdl, options) {
  var self = this;

  events.EventEmitter.call(this);

  options = options || {};
  this.path = path;
  this.services = services;
  this.wsdl = wsdl;
  this.suppressStack = options &#x26;&#x26; options.suppressStack;

  if (path[path.length - 1] !== &#x27;/&#x27;)
    path += &#x27;/&#x27;;
  wsdl.onReady(function (err) {
    if (typeof server.route === &#x27;function&#x27; &#x26;&#x26; typeof server.use === &#x27;function&#x27;) {
      //handle only the required URL path for express server
      server.route(path).all(function (req, res, next) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        self._requestListener(req, res);
      });
    } else {
      var listeners = server.listeners(&#x27;request&#x27;).slice();
      server.removeAllListeners(&#x27;request&#x27;);
      server.addListener(&#x27;request&#x27;, function (req, res) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        var reqPath = url.parse(req.url).pathname;
        if (reqPath[reqPath.length - 1] !== &#x27;/&#x27;) {
          reqPath += &#x27;/&#x27;;
        }
        if (path === reqPath) {
          self._requestListener(req, res);
        } else {
          for (var i = 0, len = listeners.length; i &#x3c; len; i++) {
            listeners[i].call(this, req, res);
          }
        }
      });
    }
  });

  this._initializeOptions(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.soap" id="apidoc.module.soap.soap">module soap.soap</a></h1>


    <h2>
        <a href="#apidoc.element.soap.soap.BasicAuthSecurity" id="apidoc.element.soap.soap.BasicAuthSecurity">
        function <span class="apidocSignatureSpan">soap.soap.</span>BasicAuthSecurity
        <span class="apidocSignatureSpan">(username, password, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BasicAuthSecurity(username, password, defaults) {
  this._username = username;
  this._password = password;
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as well.  The interface is quite simple. Each protocol defines 2 methods:
* `addOptions` - a method that accepts an options arg that is eventually passed directly to `request`
* `toXML` - a method that returns a string of XML.

### BasicAuthSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BasicAuthSecurity</span>(&#x27;username&#x27;, &#x27;password&#
x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.BearerSecurity(&#x27;token&#x27;));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.BearerSecurity" id="apidoc.element.soap.soap.BearerSecurity">
        function <span class="apidocSignatureSpan">soap.soap.</span>BearerSecurity
        <span class="apidocSignatureSpan">(token, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BearerSecurity(token, defaults) {
	this._token = token;
	this.defaults = {};
	_.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
``` javascript
  client.setSecurity(new soap.BasicAuthSecurity(&#x27;username&#x27;, &#x27;password&#x27;));
```

### BearerSecurity

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">BearerSecurity</span>(&#x27;token&#x27;));
```

### ClientSSLSecurity

_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.Client" id="apidoc.element.soap.soap.Client">
        function <span class="apidocSignatureSpan">soap.soap.</span>Client
        <span class="apidocSignatureSpan">(wsdl, endpoint, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Client = function (wsdl, endpoint, options) {
  events.EventEmitter.call(this);
  options = options || {};
  this.wsdl = wsdl;
  this._initializeOptions(options);
  this._initializeServices(endpoint);
  this.httpClient = options.httpClient || new HttpClient(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.ClientSSLSecurity" id="apidoc.element.soap.soap.ClientSSLSecurity">
        function <span class="apidocSignatureSpan">soap.soap.</span>ClientSSLSecurity
        <span class="apidocSignatureSpan">(key, cert, ca, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurity(key, cert, ca, defaults) {
  if (key) {
    if(Buffer.isBuffer(key)) {
      this.key = key;
    } else if (typeof key === &#x27;string&#x27;) {
      this.key = fs.readFileSync(key);
    } else {
      throw new Error(&#x27;key should be a buffer or a string!&#x27;);
    }
  }

  if (cert) {
    if(Buffer.isBuffer(cert)) {
      this.cert = cert;
    } else if (typeof cert === &#x27;string&#x27;) {
      this.cert = fs.readFileSync(cert);
    } else {
      throw new Error(&#x27;cert should be a buffer or a string!&#x27;);
    }
  }

  if (ca) {
    if(Buffer.isBuffer(ca) || Array.isArray(ca)) {
      this.ca = ca;
    } else if (typeof ca === &#x27;string&#x27;) {
      this.ca = fs.readFileSync(ca);
    } else {
      defaults = ca;
      this.ca = null;
    }
  }

  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_Note_: If you run into issues using this protocol, consider passing these options
as default request options to the constructor:
* `rejectUnauthorized: false`
* `strictSSL: false`
* `secureOptions: constants.SSL_OP_NO_TLSv1_2` (this is likely needed for node &#x3e;= 10.0)

``` javascript
  client.setSecurity(new soap.<span class="apidocCodeKeywordSpan">ClientSSLSecurity</span>(
    &#x27;/path/to/key&#x27;
    , &#x27;/path/to/cert&#x27;
    , {/*default request options*/}
  ));
```

### WSSecurity
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.ClientSSLSecurityPFX" id="apidoc.element.soap.soap.ClientSSLSecurityPFX">
        function <span class="apidocSignatureSpan">soap.soap.</span>ClientSSLSecurityPFX
        <span class="apidocSignatureSpan">(pfx, passphrase, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ClientSSLSecurityPFX(pfx, passphrase, defaults) {
  if (typeof passphrase === &#x27;object&#x27;) {
    defaults = passphrase;
  }
  if (pfx) {
    if (Buffer.isBuffer(pfx)) {
      this.pfx = pfx;
    } else if (typeof pfx === &#x27;string&#x27;) {
      this.pfx = fs.readFileSync(pfx);
    } else {
      throw new Error(&#x27;supplied pfx file should be a buffer or a file location&#x27;);
    }
  }

  if (passphrase) {
    if (typeof passphrase === &#x27;string&#x27;) {
      this.passphrase = passphrase;
    }
  }
  this.defaults = {};
  _.merge(this.defaults, defaults);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.HttpClient" id="apidoc.element.soap.soap.HttpClient">
        function <span class="apidocSignatureSpan">soap.soap.</span>HttpClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(options) {
  options = options || {};
  this._request = options.request || req;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.Server" id="apidoc.element.soap.soap.Server">
        function <span class="apidocSignatureSpan">soap.soap.</span>Server
        <span class="apidocSignatureSpan">(server, path, services, wsdl, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (server, path, services, wsdl, options) {
  var self = this;

  events.EventEmitter.call(this);

  options = options || {};
  this.path = path;
  this.services = services;
  this.wsdl = wsdl;
  this.suppressStack = options &#x26;&#x26; options.suppressStack;

  if (path[path.length - 1] !== &#x27;/&#x27;)
    path += &#x27;/&#x27;;
  wsdl.onReady(function (err) {
    if (typeof server.route === &#x27;function&#x27; &#x26;&#x26; typeof server.use === &#x27;function&#x27;) {
      //handle only the required URL path for express server
      server.route(path).all(function (req, res, next) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        self._requestListener(req, res);
      });
    } else {
      var listeners = server.listeners(&#x27;request&#x27;).slice();
      server.removeAllListeners(&#x27;request&#x27;);
      server.addListener(&#x27;request&#x27;, function (req, res) {
        if (typeof self.authorizeConnection === &#x27;function&#x27;) {
          if (!self.authorizeConnection(req)) {
            res.end();
            return;
          }
        }
        var reqPath = url.parse(req.url).pathname;
        if (reqPath[reqPath.length - 1] !== &#x27;/&#x27;) {
          reqPath += &#x27;/&#x27;;
        }
        if (path === reqPath) {
          self._requestListener(req, res);
        } else {
          for (var i = 0, len = listeners.length; i &#x3c; len; i++) {
            listeners[i].call(this, req, res);
          }
        }
      });
    }
  });

  this._initializeOptions(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.WSDL" id="apidoc.element.soap.soap.WSDL">
        function <span class="apidocSignatureSpan">soap.soap.</span>WSDL
        <span class="apidocSignatureSpan">(definition, uri, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WSDL = function (definition, uri, options) {
  var self = this,
      fromFunc;

  this.uri = uri;
  this.callback = function() {
  };
  this._includesWsdl = [];

  // initialize WSDL cache
  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};

  this._initializeOptions(options);

  if (typeof definition === &#x27;string&#x27;) {
    definition = stripBom(definition);
    fromFunc = this._fromXML;
  }
  else if (typeof definition === &#x27;object&#x27;) {
    fromFunc = this._fromServices;
  }
  else {
    throw new Error(&#x27;WSDL constructor takes either an XML string or service definition&#x27;);
  }

  process.nextTick(function() {
    try {
      fromFunc.call(self, definition);
    } catch (e) {
      return self.callback(e.message);
    }

    self.processIncludes(function(err) {
      var name;
      if (err) {
        return self.callback(err);
      }

      self.definitions.deleteFixedAttrs();
      var services = self.services = self.definitions.services;
      if (services) {
        for (name in services) {
          services[name].postProcess(self.definitions);
        }
      }
      var complexTypes = self.definitions.complexTypes;
      if (complexTypes) {
        for (name in complexTypes) {
          complexTypes[name].deleteFixedAttrs();
        }
      }

      // for document style, for every binding, prepare input message element name to (methodName, output message element name)
mapping
      var bindings = self.definitions.bindings;
      for (var bindingName in bindings) {
        var binding = bindings[bindingName];
        if (typeof binding.style === &#x27;undefined&#x27;) {
          binding.style = &#x27;document&#x27;;
        }
        if (binding.style !== &#x27;document&#x27;)
          continue;
        var methods = binding.methods;
        var topEls = binding.topElements = {};
        for (var methodName in methods) {
          if (methods[methodName].input) {
            var inputName = methods[methodName].input.$name;
            var outputName=&#x22;&#x22;;
            if(methods[methodName].output )
              outputName = methods[methodName].output.$name;
            topEls[inputName] = {&#x22;methodName&#x22;: methodName, &#x22;outputName&#x22;: outputName};
          }
        }
      }

      // prepare soap envelope xmlns definition string
      self.xmlnsInEnvelope = self._xmlnsMap();

      self.callback(err, self);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.WSSecurity" id="apidoc.element.soap.soap.WSSecurity">
        function <span class="apidocSignatureSpan">soap.soap.</span>WSSecurity
        <span class="apidocSignatureSpan">(username, password, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurity(username, password, options) {
  options = options || {};
  this._username = username;
  this._password = password;
  //must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = &#x27;PasswordText
&#x27;, hasTimeStamp = true
  if (typeof options === &#x27;string&#x27;) {
    this._passwordType = options ? options : &#x27;PasswordText&#x27;;
    options = {};
  } else {
    this._passwordType = options.passwordType ? options.passwordType : &#x27;PasswordText&#x27;;
  }

  if (validPasswordTypes.indexOf(this._passwordType) === -1) {
    this._passwordType = &#x27;PasswordText&#x27;;
  }

  this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === &#x27;boolean&#x27; ? !!options.hasTimeStamp : true;
  /*jshint eqnull:true */
  if (options.hasNonce != null) {
    this._hasNonce = !!options.hasNonce;
  }
  this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === &#x27;boolean&#x27; ? !!options.hasTokenCreated :
true;
  if (options.actor != null) {
    this._actor = options.actor;
  }
  if (options.mustUnderstand != null) {
    this._mustUnderstand = !!options.mustUnderstand;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.WSSecurityCert" id="apidoc.element.soap.soap.WSSecurityCert">
        function <span class="apidocSignatureSpan">soap.soap.</span>WSSecurityCert
        <span class="apidocSignatureSpan">(privatePEM, publicP12PEM, password, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WSSecurityCert(privatePEM, publicP12PEM, password, encoding) {
  if (!ursa) {
    throw new Error(&#x27;Module ursa must be installed to use WSSecurityCert&#x27;);
  }
  this.privateKey = ursa.createPrivateKey(privatePEM, password, encoding);
  this.publicP12PEM = publicP12PEM.toString().replace(&#x27;-----BEGIN CERTIFICATE-----&#x27;, &#x27;&#x27;).replace(&#x27;-----END CERTIFICATE-----&#x27;, &#x27;&#x27;).
replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;);

  this.signer = new SignedXml();
  this.signer.signingKey = this.privateKey.toPrivatePem();
  this.x509Id = &#x22;x509-&#x22; + generateId();

  var _this = this;
  this.signer.keyInfoProvider = {};
  this.signer.keyInfoProvider.getKeyInfo = function (key) {
    return wsseSecurityTokenTemplate({ x509Id: _this.x509Id });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

WS-Security X509 Certificate support.

``` javascript
  var privateKey = fs.readFileSync(privateKeyPath);
  var publicKey = fs.readFileSync(publicKeyPath);
  var password = &#x27;&#x27;; // optional password
  var wsSecurity = new soap.<span class="apidocCodeKeywordSpan">WSSecurityCert</span>(privateKey, publicKey, password, &#x27;utf8
&#x27;);
  client.setSecurity(wsSecurity);
```

_Note_: Optional dependency &#x27;ursa&#x27; is required to be installed successfully when WSSecurityCert is used.

## Handling XML Attributes, Value and XML (wsdlOptions).
Sometimes it is necessary to override the default behaviour of `node-soap` in order to deal with the special requirements
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.createClient" id="apidoc.element.soap.soap.createClient">
        function <span class="apidocSignatureSpan">soap.soap.</span>createClient
        <span class="apidocSignatureSpan">(url, options, callback, endpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClient(url, options, callback, endpoint) {
  if (typeof options === &#x27;function&#x27;) {
    endpoint = callback;
    callback = options;
    options = {};
  }
  endpoint = options.endpoint || endpoint;
  _requestWSDL(url, options, function(err, wsdl) {
    callback(err, wsdl &#x26;&#x26; new Client(wsdl, endpoint, options));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;!-- DON&#x27;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&#x3e;


- [Features:](#features)
- [Install](#install)
- [Where can I file an issue?](#where-can-i-file-an-issue)
- [Module](#module)
- [soap.<span class="apidocCodeKeywordSpan">createClient</span>(url[, options], callback) - create a new SOAP client from a WSDL
 url. Also supports a local filesystem path.](#soapcreateclienturl-options-callback---create-a-new-soap-client-from-a-wsdl-url-also
-supports-a-local-filesystem-path)
- [soap.listen(*server*, *path*, *services*, *wsdl*) - create a new SOAP server that listens on *path* and provides *services*.](#
soaplistenserver-path-services-wsdl---create-a-new-soap-server-that-listens-on-path-and-provides-services)
- [Options](#options)
- [Server Logging](#server-logging)
- [Server Events](#server-events)
- [SOAP Fault](#soap-fault)
- [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
- [Server connection authorization](#server-connection-authorization)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.listen" id="apidoc.element.soap.soap.listen">
        function <span class="apidocSignatureSpan">soap.soap.</span>listen
        <span class="apidocSignatureSpan">(server, pathOrOptions, services, xml)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(server, pathOrOptions, services, xml) {
  var options = {},
    path = pathOrOptions,
    uri = null;

  if (typeof pathOrOptions === &#x27;object&#x27;) {
    options = pathOrOptions;
    path = options.path;
    services = options.services;
    xml = options.xml;
    uri = options.uri;
  }

  var wsdl = new WSDL(xml || services, uri, options);
  return new Server(server, path, services, wsdl, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


- [Features:](#features)
- [Install](#install)
- [Where can I file an issue?](#where-can-i-file-an-issue)
- [Module](#module)
  - [soap.createClient(url[, options], callback) - create a new SOAP client from a WSDL url. Also supports a local filesystem path
.](#soapcreateclienturl-options-callback---create-a-new-soap-client-from-a-wsdl-url-also-supports-a-local-filesystem-path)
  - [soap.<span class="apidocCodeKeywordSpan">listen</span>(*server*, *path*, *services*, *wsdl*) - create a new SOAP server that
 listens on *path* and provides *services*.](#soaplistenserver-path-services-wsdl---create-a-new-soap-server-that-listens-on-path
-and-provides-services)
  - [Options](#options)
  - [Server Logging](#server-logging)
  - [Server Events](#server-events)
  - [SOAP Fault](#soap-fault)
  - [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
  - [Server connection authorization](#server-connection-authorization)
- [SOAP Headers](#soap-headers)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap.passwordDigest" id="apidoc.element.soap.soap.passwordDigest">
        function <span class="apidocSignatureSpan">soap.soap.</span>passwordDigest
        <span class="apidocSignatureSpan">(nonce, created, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function passwordDigest(nonce, created, password) {
  // digest = base64 ( sha1 ( nonce + created + password ) )
  var pwHash = crypto.createHash(&#x27;sha1&#x27;);
  var rawNonce = new Buffer(nonce || &#x27;&#x27;, &#x27;base64&#x27;).toString(&#x27;binary&#x27;);
  pwHash.update(rawNonce + created + password);
  return pwHash.digest(&#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` javascript
  server = soap.listen(...)
  server.authenticate = function(security) {
    var created, nonce, password, user, token;
    token = security.UsernameToken, user = token.Username,
            password = token.Password, nonce = token.Nonce, created = token.Created;
    return user === &#x27;user&#x27; &#x26;&#x26; password === soap.<span class="apidocCodeKeywordSpan">passwordDigest</span>(nonce
, created, &#x27;password&#x27;);
  };
```

### Server connection authorization

The `server.authorizeConnection` method is called prior to the soap service method.
If the method is defined and returns `false` then the incoming connection is
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.soap_stub" id="apidoc.module.soap.soap_stub">module soap.soap_stub</a></h1>




    <h2>
        <a href="#apidoc.element.soap.soap_stub.createClient" id="apidoc.element.soap.soap_stub.createClient">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>createClient
        <span class="apidocSignatureSpan">(wsdlUrl, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClient(wsdlUrl, options, cb) {
  if (!cb) {
    cb = options;
    options = {};
  }

  if (this.errOnCreateClient) {
    return setTimeout(cb.bind(null, new Error(&#x27;forced error on createClient&#x27;)));
  }

  var client = getStub(wsdlUrl);

  if (client) {
    resetStubbedMethods(client);
    setTimeout(cb.bind(null, null, client));
  } else {
    setTimeout(cb.bind(null, new Error(&#x27;no client stubbed for &#x27; + wsdlUrl)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;!-- DON&#x27;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&#x3e;


- [Features:](#features)
- [Install](#install)
- [Where can I file an issue?](#where-can-i-file-an-issue)
- [Module](#module)
- [soap.<span class="apidocCodeKeywordSpan">createClient</span>(url[, options], callback) - create a new SOAP client from a WSDL
 url. Also supports a local filesystem path.](#soapcreateclienturl-options-callback---create-a-new-soap-client-from-a-wsdl-url-also
-supports-a-local-filesystem-path)
- [soap.listen(*server*, *path*, *services*, *wsdl*) - create a new SOAP server that listens on *path* and provides *services*.](#
soaplistenserver-path-services-wsdl---create-a-new-soap-server-that-listens-on-path-and-provides-services)
- [Options](#options)
- [Server Logging](#server-logging)
- [Server Events](#server-events)
- [SOAP Fault](#soap-fault)
- [Server security example using PasswordDigest](#server-security-example-using-passworddigest)
- [Server connection authorization](#server-connection-authorization)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap_stub.createErroringStub" id="apidoc.element.soap.soap_stub.createErroringStub">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>createErroringStub
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createErroringStub(err) {
  return function() {
    this.args.forEach(function(argSet) {
      setTimeout(argSet[1].bind(null, err));
    });
    this.yields(err);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var soapStub = require(&#x27;soap/soap-stub&#x27;);

var urlMyApplicationWillUseWithCreateClient = &#x27;http://path-to-my-wsdl&#x27;;
var clientStub = {
  SomeOperation: sinon.stub()
};

clientStub.SomeOperation.respondWithError = soapStub.<span class="apidocCodeKeywordSpan">createErroringStub</span>({..error json
...});
clientStub.SomeOperation.respondWithSuccess = soapStub.createRespondingStub({..success json...});

soapStub.registerClient(&#x27;my client alias&#x27;, urlMyApplicationWillUseWithCreateClient, clientStub);

// test.js
var soapStub = require(&#x27;soap/soap-stub&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap_stub.createRespondingStub" id="apidoc.element.soap.soap_stub.createRespondingStub">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>createRespondingStub
        <span class="apidocSignatureSpan">(object, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRespondingStub(object, body) {
  return function() {
    this.args.forEach(function(argSet) {
      setTimeout(argSet[1].bind(null, null, object));
    });
    this.yields(null, object, body);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var urlMyApplicationWillUseWithCreateClient = &#x27;http://path-to-my-wsdl&#x27;;
var clientStub = {
  SomeOperation: sinon.stub()
};

clientStub.SomeOperation.respondWithError = soapStub.createErroringStub({..error json...});
clientStub.SomeOperation.respondWithSuccess = soapStub.<span class="apidocCodeKeywordSpan">createRespondingStub</span>({..success
 json...});

soapStub.registerClient(&#x27;my client alias&#x27;, urlMyApplicationWillUseWithCreateClient, clientStub);

// test.js
var soapStub = require(&#x27;soap/soap-stub&#x27;);

describe(&#x27;myService&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap_stub.getStub" id="apidoc.element.soap.soap_stub.getStub">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>getStub
        <span class="apidocSignatureSpan">(aliasOrWsdlUrl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStub(aliasOrWsdlUrl) {
  return aliasedClientStubs[aliasOrWsdlUrl] || clientStubs[aliasOrWsdlUrl];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var soapStub = require(&#x27;soap/soap-stub&#x27;);

describe(&#x27;myService&#x27;, function() {
var clientStub;
var myService;

beforeEach(function() {
  clientStub = soapStub.<span class="apidocCodeKeywordSpan">getStub</span>(&#x27;my client alias&#x27;);
  soapStub.reset();
  myService.init(clientStub);
});

describe(&#x27;failures&#x27;, function() {
  beforeEach(function() {
    clientStub.SomeOperation.respondWithError();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap_stub.registerClient" id="apidoc.element.soap.soap_stub.registerClient">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>registerClient
        <span class="apidocSignatureSpan">(alias, urlToWsdl, clientStub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerClient(alias, urlToWsdl, clientStub) {
  aliasedClientStubs[alias] = clientStub;
  clientStubs[urlToWsdl] = clientStub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var clientStub = {
SomeOperation: sinon.stub()
};

clientStub.SomeOperation.respondWithError = soapStub.createErroringStub({..error json...});
clientStub.SomeOperation.respondWithSuccess = soapStub.createRespondingStub({..success json...});

soapStub.<span class="apidocCodeKeywordSpan">registerClient</span>(&#x27;my client alias&#x27;, urlMyApplicationWillUseWithCreateClient
, clientStub);

// test.js
var soapStub = require(&#x27;soap/soap-stub&#x27;);

describe(&#x27;myService&#x27;, function() {
var clientStub;
var myService;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.soap_stub.reset" id="apidoc.element.soap.soap_stub.reset">
        function <span class="apidocSignatureSpan">soap.soap_stub.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  _.forEach(clientStubs, resetStubbedMethods);
  this.errOnCreateClient = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

describe(&#x27;myService&#x27;, function() {
var clientStub;
var myService;

beforeEach(function() {
  clientStub = soapStub.getStub(&#x27;my client alias&#x27;);
  soapStub.<span class="apidocCodeKeywordSpan">reset</span>();
  myService.init(clientStub);
});

describe(&#x27;failures&#x27;, function() {
  beforeEach(function() {
    clientStub.SomeOperation.respondWithError();
  });
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.utils" id="apidoc.module.soap.utils">module soap.utils</a></h1>


    <h2>
        <a href="#apidoc.element.soap.utils.findPrefix" id="apidoc.element.soap.utils.findPrefix">
        function <span class="apidocSignatureSpan">soap.utils.</span>findPrefix
        <span class="apidocSignatureSpan">(xmlnsMapping, nsURI)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPrefix = function (xmlnsMapping, nsURI) {
  for (var n in xmlnsMapping) {
    if (n === TNS_PREFIX) continue;
    if (xmlnsMapping[n] === nsURI) {
      return n;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.utils.passwordDigest" id="apidoc.element.soap.utils.passwordDigest">
        function <span class="apidocSignatureSpan">soap.utils.</span>passwordDigest
        <span class="apidocSignatureSpan">(nonce, created, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function passwordDigest(nonce, created, password) {
  // digest = base64 ( sha1 ( nonce + created + password ) )
  var pwHash = crypto.createHash(&#x27;sha1&#x27;);
  var rawNonce = new Buffer(nonce || &#x27;&#x27;, &#x27;base64&#x27;).toString(&#x27;binary&#x27;);
  pwHash.update(rawNonce + created + password);
  return pwHash.digest(&#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` javascript
  server = soap.listen(...)
  server.authenticate = function(security) {
    var created, nonce, password, user, token;
    token = security.UsernameToken, user = token.Username,
            password = token.Password, nonce = token.Nonce, created = token.Created;
    return user === &#x27;user&#x27; &#x26;&#x26; password === soap.<span class="apidocCodeKeywordSpan">passwordDigest</span>(nonce
, created, &#x27;password&#x27;);
  };
```

### Server connection authorization

The `server.authorizeConnection` method is called prior to the soap service method.
If the method is defined and returns `false` then the incoming connection is
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.soap.wsdl" id="apidoc.module.soap.wsdl">module soap.wsdl</a></h1>


    <h2>
        <a href="#apidoc.element.soap.wsdl.WSDL" id="apidoc.element.soap.wsdl.WSDL">
        function <span class="apidocSignatureSpan">soap.wsdl.</span>WSDL
        <span class="apidocSignatureSpan">(definition, uri, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WSDL = function (definition, uri, options) {
  var self = this,
      fromFunc;

  this.uri = uri;
  this.callback = function() {
  };
  this._includesWsdl = [];

  // initialize WSDL cache
  this.WSDL_CACHE = (options || {}).WSDL_CACHE || {};

  this._initializeOptions(options);

  if (typeof definition === &#x27;string&#x27;) {
    definition = stripBom(definition);
    fromFunc = this._fromXML;
  }
  else if (typeof definition === &#x27;object&#x27;) {
    fromFunc = this._fromServices;
  }
  else {
    throw new Error(&#x27;WSDL constructor takes either an XML string or service definition&#x27;);
  }

  process.nextTick(function() {
    try {
      fromFunc.call(self, definition);
    } catch (e) {
      return self.callback(e.message);
    }

    self.processIncludes(function(err) {
      var name;
      if (err) {
        return self.callback(err);
      }

      self.definitions.deleteFixedAttrs();
      var services = self.services = self.definitions.services;
      if (services) {
        for (name in services) {
          services[name].postProcess(self.definitions);
        }
      }
      var complexTypes = self.definitions.complexTypes;
      if (complexTypes) {
        for (name in complexTypes) {
          complexTypes[name].deleteFixedAttrs();
        }
      }

      // for document style, for every binding, prepare input message element name to (methodName, output message element name)
mapping
      var bindings = self.definitions.bindings;
      for (var bindingName in bindings) {
        var binding = bindings[bindingName];
        if (typeof binding.style === &#x27;undefined&#x27;) {
          binding.style = &#x27;document&#x27;;
        }
        if (binding.style !== &#x27;document&#x27;)
          continue;
        var methods = binding.methods;
        var topEls = binding.topElements = {};
        for (var methodName in methods) {
          if (methods[methodName].input) {
            var inputName = methods[methodName].input.$name;
            var outputName=&#x22;&#x22;;
            if(methods[methodName].output )
              outputName = methods[methodName].output.$name;
            topEls[inputName] = {&#x22;methodName&#x22;: methodName, &#x22;outputName&#x22;: outputName};
          }
        }
      }

      // prepare soap envelope xmlns definition string
      self.xmlnsInEnvelope = self._xmlnsMap();

      self.callback(err, self);
    });

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.soap.wsdl.open_wsdl" id="apidoc.element.soap.wsdl.open_wsdl">
        function <span class="apidocSignatureSpan">soap.wsdl.</span>open_wsdl
        <span class="apidocSignatureSpan">(uri, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function open_wsdl(uri, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  // initialize cache when calling open_wsdl directly
  var WSDL_CACHE = options.WSDL_CACHE || {};
  var request_headers = options.wsdl_headers;
  var request_options = options.wsdl_options;

  var wsdl;
  if (!/^https?:/.test(uri)) {
    debug(&#x27;Reading file: %s&#x27;, uri);
    fs.readFile(uri, &#x27;utf8&#x27;, function(err, definition) {
      if (err) {
        callback(err);
      }
      else {
        wsdl = new WSDL(definition, uri, options);
        WSDL_CACHE[ uri ] = wsdl;
        wsdl.WSDL_CACHE = WSDL_CACHE;
        wsdl.onReady(callback);
      }
    });
  }
  else {
    debug(&#x27;Reading url: %s&#x27;, uri);
    var httpClient = options.httpClient || new HttpClient(options);
    httpClient.request(uri, null /* options */, function(err, response, definition) {
      if (err) {
        callback(err);
      } else if (response &#x26;&#x26; response.statusCode === 200) {
        wsdl = new WSDL(definition, uri, options);
        WSDL_CACHE[ uri ] = wsdl;
        wsdl.WSDL_CACHE = WSDL_CACHE;
        wsdl.onReady(callback);
      } else {
        callback(new Error(&#x27;Invalid WSDL URL: &#x27; + uri + &#x22;\n\n\r Code: &#x22; + response.statusCode + &#x22;\n\n\r Response Body: &#x22; + response
.body));
      }
    }, request_headers, request_options);
  }

  return wsdl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
